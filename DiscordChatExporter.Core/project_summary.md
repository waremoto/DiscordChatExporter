# .aidigestignore

```
obj bin project_summary.md Discord/Data/EmojiIndex.cs
```

# Discord/Data/Application.cs

```cs
using System.Text.Json; using DiscordChatExporter.Core.Utils.Extensions; using JsonExtensions.Reading; namespace DiscordChatExporter.Core.Discord.Data; // https://discord.com/developers/docs/resources/application#application-object public partial record Application(Snowflake Id, string Name, ApplicationFlags Flags) { public bool IsMessageContentIntentEnabled => Flags.HasFlag(ApplicationFlags.GatewayMessageContent) || Flags.HasFlag(ApplicationFlags.GatewayMessageContentLimited); } public partial record Application { public static Application Parse(JsonElement json) { var id = json.GetProperty("id").GetNonWhiteSpaceString().Pipe(Snowflake.Parse); var name = json.GetProperty("name").GetNonWhiteSpaceString(); var flags = json.GetPropertyOrNull("flags")?.GetInt32OrNull()?.Pipe(x => (ApplicationFlags)x) ?? ApplicationFlags.None; return new Application(id, name, flags); } }
```

# Discord/Data/ApplicationFlags.cs

```cs
using System; namespace DiscordChatExporter.Core.Discord.Data; // https://discord.com/developers/docs/resources/application#application-object-application-flags [Flags] public enum ApplicationFlags { None = 0, ApplicationAutoModerationRuleCreateBadge = 64, GatewayPresence = 4096, GatewayPresenceLimited = 8192, GatewayGuildMembers = 16384, GatewayGuildMembersLimited = 32768, VerificationPendingGuildLimit = 65536, Embedded = 131072, GatewayMessageContent = 262144, GatewayMessageContentLimited = 524288, ApplicationCommandBadge = 8388608, }
```

# Discord/Data/Attachment.cs

```cs
using System; using System.IO; using System.Text.Json; using DiscordChatExporter.Core.Discord.Data.Common; using DiscordChatExporter.Core.Utils.Extensions; using JsonExtensions.Reading; namespace DiscordChatExporter.Core.Discord.Data; // https://discord.com/developers/docs/resources/channel#attachment-object public partial record Attachment( Snowflake Id, string Url, string FileName, string? Description, int? Width, int? Height, FileSize FileSize ) : IHasId { public string FileExtension => Path.GetExtension(FileName); public bool IsImage => string.Equals(FileExtension, ".jpg", StringComparison.OrdinalIgnoreCase) || string.Equals(FileExtension, ".jpeg", StringComparison.OrdinalIgnoreCase) || string.Equals(FileExtension, ".png", StringComparison.OrdinalIgnoreCase) || string.Equals(FileExtension, ".gif", StringComparison.OrdinalIgnoreCase) || string.Equals(FileExtension, ".bmp", StringComparison.OrdinalIgnoreCase) || string.Equals(FileExtension, ".webp", StringComparison.OrdinalIgnoreCase); public bool IsVideo => string.Equals(FileExtension, ".gifv", StringComparison.OrdinalIgnoreCase) || string.Equals(FileExtension, ".mp4", StringComparison.OrdinalIgnoreCase) || string.Equals(FileExtension, ".webm", StringComparison.OrdinalIgnoreCase) || string.Equals(FileExtension, ".mov", StringComparison.OrdinalIgnoreCase); public bool IsAudio => string.Equals(FileExtension, ".mp3", StringComparison.OrdinalIgnoreCase) || string.Equals(FileExtension, ".wav", StringComparison.OrdinalIgnoreCase) || string.Equals(FileExtension, ".ogg", StringComparison.OrdinalIgnoreCase) || string.Equals(FileExtension, ".flac", StringComparison.OrdinalIgnoreCase) || string.Equals(FileExtension, ".m4a", StringComparison.OrdinalIgnoreCase); public bool IsSpoiler => FileName.StartsWith("SPOILER_", StringComparison.Ordinal); } public partial record Attachment { public static Attachment Parse(JsonElement json) { var id = json.GetProperty("id").GetNonWhiteSpaceString().Pipe(Snowflake.Parse); var url = json.GetProperty("url").GetNonWhiteSpaceString(); var fileName = json.GetProperty("filename").GetNonNullString(); var description = json.GetPropertyOrNull("description")?.GetNonWhiteSpaceStringOrNull(); var width = json.GetPropertyOrNull("width")?.GetInt32OrNull(); var height = json.GetPropertyOrNull("height")?.GetInt32OrNull(); var fileSize = json.GetProperty("size").GetInt64().Pipe(FileSize.FromBytes); return new Attachment(id, url, fileName, description, width, height, fileSize); } }
```

# Discord/Data/Channel.cs

```cs
using System.Collections.Generic; using System.Linq; using System.Text.Json; using DiscordChatExporter.Core.Discord.Data.Common; using DiscordChatExporter.Core.Utils.Extensions; using JsonExtensions.Reading; namespace DiscordChatExporter.Core.Discord.Data; // https://discord.com/developers/docs/resources/channel#channel-object public partial record Channel( Snowflake Id, ChannelKind Kind, Snowflake GuildId, Channel? Parent, string Name, int? Position, string? IconUrl, string? Topic, bool IsArchived, Snowflake? LastMessageId ) : IHasId { public bool IsDirect => Kind is ChannelKind.DirectTextChat or ChannelKind.DirectGroupTextChat; public bool IsGuild => !IsDirect; public bool IsCategory => Kind == ChannelKind.GuildCategory; public bool IsVoice => Kind is ChannelKind.GuildVoiceChat or ChannelKind.GuildStageVoice; public bool IsThread => Kind is ChannelKind.GuildNewsThread or ChannelKind.GuildPublicThread or ChannelKind.GuildPrivateThread; public bool IsEmpty => LastMessageId is null; public IEnumerable<Channel> GetParents() { var current = Parent; while (current is not null) { yield return current; current = current.Parent; } } public Channel? TryGetRootParent() => GetParents().LastOrDefault(); public string GetHierarchicalName() => string.Join(" / ", GetParents().Reverse().Select(c => c.Name).Append(Name)); public bool MayHaveMessagesAfter(Snowflake messageId) => !IsEmpty && messageId < LastMessageId; public bool MayHaveMessagesBefore(Snowflake messageId) => !IsEmpty && messageId > Id; } public partial record Channel { public static Channel Parse(JsonElement json, Channel? parent = null, int? positionHint = null) { var id = json.GetProperty("id").GetNonWhiteSpaceString().Pipe(Snowflake.Parse); var kind = json.GetProperty("type").GetInt32().Pipe(t => (ChannelKind)t); var guildId = json.GetPropertyOrNull("guild_id") ?.GetNonWhiteSpaceStringOrNull() ?.Pipe(Snowflake.Parse) ?? Guild.DirectMessages.Id; var name = // Guild channel json.GetPropertyOrNull("name")?.GetNonWhiteSpaceStringOrNull() // DM channel ?? json.GetPropertyOrNull("recipients") ?.EnumerateArrayOrNull() ?.Select(User.Parse) .Select(u => u.DisplayName) .Pipe(s => string.Join(", ", s)) // Fallback ?? id.ToString(); var position = positionHint ?? json.GetPropertyOrNull("position")?.GetInt32OrNull(); // Icons can only be set for group DM channels var iconUrl = json.GetPropertyOrNull("icon") ?.GetNonWhiteSpaceStringOrNull() ?.Pipe(h => ImageCdn.GetChannelIconUrl(id, h)); var topic = json.GetPropertyOrNull("topic")?.GetStringOrNull(); var isArchived = json.GetPropertyOrNull("thread_metadata") ?.GetPropertyOrNull("archived") ?.GetBooleanOrNull() ?? false; var lastMessageId = json.GetPropertyOrNull("last_message_id") ?.GetNonWhiteSpaceStringOrNull() ?.Pipe(Snowflake.Parse); return new Channel( id, kind, guildId, parent, name, position, iconUrl, topic, isArchived, lastMessageId ); } }
```

# Discord/Data/ChannelKind.cs

```cs
namespace DiscordChatExporter.Core.Discord.Data; // https://discord.com/developers/docs/resources/channel#channel-object-channel-types public enum ChannelKind { GuildTextChat = 0, DirectTextChat = 1, GuildVoiceChat = 2, DirectGroupTextChat = 3, GuildCategory = 4, GuildNews = 5, GuildNewsThread = 10, GuildPublicThread = 11, GuildPrivateThread = 12, GuildStageVoice = 13, GuildDirectory = 14, GuildForum = 15, }
```

# Discord/Data/ChannelNode.cs

```cs
using System.Collections.Generic; using System.Linq; namespace DiscordChatExporter.Core.Discord.Data; public record ChannelNode(Channel Channel, IReadOnlyList<ChannelNode> Children) { public static IReadOnlyList<ChannelNode> BuildTree(IReadOnlyList<Channel> channels) { IReadOnlyList<ChannelNode> GetChildren(Channel parent) => channels .Where(c => c.Parent?.Id == parent.Id) .Select(c => new ChannelNode(c, GetChildren(c))) .ToArray(); return channels .Where(c => c.Parent is null) .Select(c => new ChannelNode(c, GetChildren(c))) .ToArray(); } }
```

# Discord/Data/Common/FileSize.cs

```cs
using System; using System.Diagnostics.CodeAnalysis; using System.Globalization; namespace DiscordChatExporter.Core.Discord.Data.Common; // Loosely based on https://github.com/omar/ByteSize (MIT license) public readonly partial record struct FileSize(long TotalBytes) { public double TotalKiloBytes => TotalBytes / 1024.0; public double TotalMegaBytes => TotalKiloBytes / 1024.0; public double TotalGigaBytes => TotalMegaBytes / 1024.0; private double GetLargestWholeNumberValue() { if (Math.Abs(TotalGigaBytes) >= 1) return TotalGigaBytes; if (Math.Abs(TotalMegaBytes) >= 1) return TotalMegaBytes; if (Math.Abs(TotalKiloBytes) >= 1) return TotalKiloBytes; return TotalBytes; } private string GetLargestWholeNumberSymbol() { if (Math.Abs(TotalGigaBytes) >= 1) return "GB"; if (Math.Abs(TotalMegaBytes) >= 1) return "MB"; if (Math.Abs(TotalKiloBytes) >= 1) return "KB"; return "bytes"; } [ExcludeFromCodeCoverage] public override string ToString() => string.Create( CultureInfo.InvariantCulture, $"{GetLargestWholeNumberValue():0.##} {GetLargestWholeNumberSymbol()}" ); } public partial record struct FileSize { public static FileSize FromBytes(long bytes) => new(bytes); }
```

# Discord/Data/Common/IHasId.cs

```cs
namespace DiscordChatExporter.Core.Discord.Data.Common; public interface IHasId { Snowflake Id { get; } }
```

# Discord/Data/Common/ImageCdn.cs

```cs
using System; using System.Globalization; using System.Linq; namespace DiscordChatExporter.Core.Discord.Data.Common; // https://discord.com/developers/docs/reference#image-formatting public static class ImageCdn { // Standard emoji are rendered through Twemoji public static string GetStandardEmojiUrl(string emojiName) { var runes = emojiName.EnumerateRunes().ToArray(); // Variant selector rune is skipped in Twemoji IDs, // except when the emoji also contains a zero-width joiner. // VS = 0xfe0f; ZWJ = 0x200d. var filteredRunes = runes.Any(r => r.Value == 0x200d) ? runes : runes.Where(r => r.Value != 0xfe0f); var twemojiId = string.Join( "-", filteredRunes.Select(r => r.Value.ToString("x", CultureInfo.InvariantCulture)) ); return $"https://cdn.jsdelivr.net/gh/twitter/twemoji@latest/assets/svg/{twemojiId}.svg"; } public static string GetCustomEmojiUrl(Snowflake emojiId, bool isAnimated = false) => isAnimated ? $"https://cdn.discordapp.com/emojis/{emojiId}.gif" : $"https://cdn.discordapp.com/emojis/{emojiId}.png"; public static string GetGuildIconUrl(Snowflake guildId, string iconHash, int size = 512) => iconHash.StartsWith("a_", StringComparison.Ordinal) ? $"https://cdn.discordapp.com/icons/{guildId}/{iconHash}.gif?size={size}" : $"https://cdn.discordapp.com/icons/{guildId}/{iconHash}.png?size={size}"; public static string GetChannelIconUrl(Snowflake channelId, string iconHash, int size = 512) => iconHash.StartsWith("a_", StringComparison.Ordinal) ? $"https://cdn.discordapp.com/channel-icons/{channelId}/{iconHash}.gif?size={size}" : $"https://cdn.discordapp.com/channel-icons/{channelId}/{iconHash}.png?size={size}"; public static string GetUserAvatarUrl(Snowflake userId, string avatarHash, int size = 512) => avatarHash.StartsWith("a_", StringComparison.Ordinal) ? $"https://cdn.discordapp.com/avatars/{userId}/{avatarHash}.gif?size={size}" : $"https://cdn.discordapp.com/avatars/{userId}/{avatarHash}.png?size={size}"; public static string GetFallbackUserAvatarUrl(int index = 0) => $"https://cdn.discordapp.com/embed/avatars/{index}.png"; public static string GetMemberAvatarUrl( Snowflake guildId, Snowflake userId, string avatarHash, int size = 512 ) => avatarHash.StartsWith("a_", StringComparison.Ordinal) ? $"https://cdn.discordapp.com/guilds/{guildId}/users/{userId}/avatars/{avatarHash}.gif?size={size}" : $"https://cdn.discordapp.com/guilds/{guildId}/users/{userId}/avatars/{avatarHash}.png?size={size}"; public static string GetStickerUrl(Snowflake stickerId, string format = "png") => $"https://cdn.discordapp.com/stickers/{stickerId}.{format}"; }
```

# Discord/Data/Embeds/Embed.cs

```cs
using System; using System.Collections.Generic; using System.Drawing; using System.Linq; using System.Text.Json; using DiscordChatExporter.Core.Utils.Extensions; using JsonExtensions.Reading; namespace DiscordChatExporter.Core.Discord.Data.Embeds; // https://discord.com/developers/docs/resources/channel#embed-object public partial record Embed( string? Title, EmbedKind Kind, string? Url, DateTimeOffset? Timestamp, Color? Color, EmbedAuthor? Author, string? Description, IReadOnlyList<EmbedField> Fields, EmbedImage? Thumbnail, IReadOnlyList<EmbedImage> Images, EmbedVideo? Video, EmbedFooter? Footer ) { // Embeds can only have one image according to the API model, // but the client can render multiple images in some cases. public EmbedImage? Image => Images.FirstOrDefault(); public SpotifyTrackEmbedProjection? TryGetSpotifyTrack() => SpotifyTrackEmbedProjection.TryResolve(this); public TwitchClipEmbedProjection? TryGetTwitchClip() => TwitchClipEmbedProjection.TryResolve(this); public YouTubeVideoEmbedProjection? TryGetYouTubeVideo() => YouTubeVideoEmbedProjection.TryResolve(this); } public partial record Embed { public static Embed Parse(JsonElement json) { var title = json.GetPropertyOrNull("title")?.GetStringOrNull(); var kind = json.GetPropertyOrNull("type")?.GetStringOrNull()?.ParseEnumOrNull<EmbedKind>() ?? EmbedKind.Rich; var url = json.GetPropertyOrNull("url")?.GetNonWhiteSpaceStringOrNull(); var timestamp = json.GetPropertyOrNull("timestamp")?.GetDateTimeOffsetOrNull(); var color = json.GetPropertyOrNull("color") ?.GetInt32OrNull() ?.Pipe(System.Drawing.Color.FromArgb) .ResetAlpha(); var author = json.GetPropertyOrNull("author")?.Pipe(EmbedAuthor.Parse); var description = json.GetPropertyOrNull("description")?.GetStringOrNull(); var fields = json.GetPropertyOrNull("fields") ?.EnumerateArrayOrNull() ?.Select(EmbedField.Parse) .ToArray() ?? []; var thumbnail = json.GetPropertyOrNull("thumbnail")?.Pipe(EmbedImage.Parse); // Under the Discord API model, embeds can only have at most one image. // Because of that, embeds that are rendered with multiple images on the client // (e.g. tweet embeds), are exposed from the API as multiple separate embeds. // Our embed model is consistent with the user-facing side of Discord, so images // are stored as an array. The API will only ever return one image, but we deal // with this by merging related embeds at the end of the message parsing process. // https://github.com/Tyrrrz/DiscordChatExporter/issues/695 var images = json.GetPropertyOrNull("image") ?.Pipe(EmbedImage.Parse) .ToSingletonEnumerable() .ToArray() ?? []; var video = json.GetPropertyOrNull("video")?.Pipe(EmbedVideo.Parse); var footer = json.GetPropertyOrNull("footer")?.Pipe(EmbedFooter.Parse); return new Embed( title, kind, url, timestamp, color, author, description, fields, thumbnail, images, video, footer ); } }
```

# Discord/Data/Embeds/EmbedAuthor.cs

```cs
using System.Text.Json; using JsonExtensions.Reading; namespace DiscordChatExporter.Core.Discord.Data.Embeds; // https://discord.com/developers/docs/resources/channel#embed-object-embed-author-structure public record EmbedAuthor(string? Name, string? Url, string? IconUrl, string? IconProxyUrl) { public static EmbedAuthor Parse(JsonElement json) { var name = json.GetPropertyOrNull("name")?.GetStringOrNull(); var url = json.GetPropertyOrNull("url")?.GetNonWhiteSpaceStringOrNull(); var iconUrl = json.GetPropertyOrNull("icon_url")?.GetNonWhiteSpaceStringOrNull(); var iconProxyUrl = json.GetPropertyOrNull("proxy_icon_url")?.GetNonWhiteSpaceStringOrNull(); return new EmbedAuthor(name, url, iconUrl, iconProxyUrl); } }
```

# Discord/Data/Embeds/EmbedField.cs

```cs
using System.Text.Json; using JsonExtensions.Reading; namespace DiscordChatExporter.Core.Discord.Data.Embeds; // https://discord.com/developers/docs/resources/channel#embed-object-embed-field-structure public record EmbedField(string Name, string Value, bool IsInline) { public static EmbedField Parse(JsonElement json) { var name = json.GetProperty("name").GetNonNullString(); var value = json.GetProperty("value").GetNonNullString(); var isInline = json.GetPropertyOrNull("inline")?.GetBooleanOrNull() ?? false; return new EmbedField(name, value, isInline); } }
```

# Discord/Data/Embeds/EmbedFooter.cs

```cs
using System.Text.Json; using JsonExtensions.Reading; namespace DiscordChatExporter.Core.Discord.Data.Embeds; // https://discord.com/developers/docs/resources/channel#embed-object-embed-footer-structure public record EmbedFooter(string Text, string? IconUrl, string? IconProxyUrl) { public static EmbedFooter Parse(JsonElement json) { var text = json.GetProperty("text").GetNonNullString(); var iconUrl = json.GetPropertyOrNull("icon_url")?.GetNonWhiteSpaceStringOrNull(); var iconProxyUrl = json.GetPropertyOrNull("proxy_icon_url")?.GetNonWhiteSpaceStringOrNull(); return new EmbedFooter(text, iconUrl, iconProxyUrl); } }
```

# Discord/Data/Embeds/EmbedImage.cs

```cs
using System.Text.Json; using JsonExtensions.Reading; namespace DiscordChatExporter.Core.Discord.Data.Embeds; // https://discord.com/developers/docs/resources/channel#embed-object-embed-image-structure public record EmbedImage(string? Url, string? ProxyUrl, int? Width, int? Height) { public static EmbedImage Parse(JsonElement json) { var url = json.GetPropertyOrNull("url")?.GetNonWhiteSpaceStringOrNull(); var proxyUrl = json.GetPropertyOrNull("proxy_url")?.GetNonWhiteSpaceStringOrNull(); var width = json.GetPropertyOrNull("width")?.GetInt32OrNull(); var height = json.GetPropertyOrNull("height")?.GetInt32OrNull(); return new EmbedImage(url, proxyUrl, width, height); } }
```

# Discord/Data/Embeds/EmbedKind.cs

```cs
namespace DiscordChatExporter.Core.Discord.Data.Embeds; // https://discord.com/developers/docs/resources/channel#embed-object-embed-types public enum EmbedKind { Rich, Image, Video, Gifv, Link, }
```

# Discord/Data/Embeds/EmbedVideo.cs

```cs
using System.Text.Json; using JsonExtensions.Reading; namespace DiscordChatExporter.Core.Discord.Data.Embeds; // https://discord.com/developers/docs/resources/channel#embed-object-embed-video-structure public record EmbedVideo(string? Url, string? ProxyUrl, int? Width, int? Height) { public static EmbedVideo Parse(JsonElement json) { var url = json.GetPropertyOrNull("url")?.GetNonWhiteSpaceStringOrNull(); var proxyUrl = json.GetPropertyOrNull("proxy_url")?.GetNonWhiteSpaceStringOrNull(); var width = json.GetPropertyOrNull("width")?.GetInt32OrNull(); var height = json.GetPropertyOrNull("height")?.GetInt32OrNull(); return new EmbedVideo(url, proxyUrl, width, height); } }
```

# Discord/Data/Embeds/SpotifyTrackEmbedProjection.cs

```cs
using System.Text.RegularExpressions; namespace DiscordChatExporter.Core.Discord.Data.Embeds; public partial record SpotifyTrackEmbedProjection(string TrackId) { public string Url => $"https://open.spotify.com/embed/track/{TrackId}"; } public partial record SpotifyTrackEmbedProjection { private static string? TryParseTrackId(string embedUrl) { // https://open.spotify.com/track/1LHZMWefF9502NPfArRfvP?si=3efac6ce9be04f0a var trackId = Regex .Match(embedUrl, @"spotify\.com/track/(.*?)(?:\?|&|/|$)") .Groups[1] .Value; if (!string.IsNullOrWhiteSpace(trackId)) return trackId; return null; } public static SpotifyTrackEmbedProjection? TryResolve(Embed embed) { if (embed.Kind != EmbedKind.Link) return null; if (string.IsNullOrWhiteSpace(embed.Url)) return null; var trackId = TryParseTrackId(embed.Url); if (string.IsNullOrWhiteSpace(trackId)) return null; return new SpotifyTrackEmbedProjection(trackId); } }
```

# Discord/Data/Embeds/TwitchClipEmbedProjection.cs

```cs
using System.Text.RegularExpressions; namespace DiscordChatExporter.Core.Discord.Data.Embeds; public partial record TwitchClipEmbedProjection(string ClipId) { public string Url => $"https://clips.twitch.tv/embed?clip={ClipId}&parent=localhost"; } public partial record TwitchClipEmbedProjection { private static string? TryParseClipId(string embedUrl) { // https://clips.twitch.tv/SpookyTenuousPidgeonPanicVis { var clipId = Regex .Match(embedUrl, @"clips\.twitch\.tv/(.*?)(?:\?|&|/|$)") .Groups[1] .Value; if (!string.IsNullOrWhiteSpace(clipId)) return clipId; } // https://twitch.tv/clip/SpookyTenuousPidgeonPanicVis { var clipId = Regex .Match(embedUrl, @"twitch\.tv/clip/(.*?)(?:\?|&|/|$)") .Groups[1] .Value; if (!string.IsNullOrWhiteSpace(clipId)) return clipId; } return null; } public static TwitchClipEmbedProjection? TryResolve(Embed embed) { if (embed.Kind != EmbedKind.Video) return null; if (string.IsNullOrWhiteSpace(embed.Url)) return null; var clipId = TryParseClipId(embed.Url); if (string.IsNullOrWhiteSpace(clipId)) return null; return new TwitchClipEmbedProjection(clipId); } }
```

# Discord/Data/Embeds/YouTubeVideoEmbedProjection.cs

```cs
namespace DiscordChatExporter.Core.Discord.Data.Embeds; public partial record YouTubeVideoEmbedProjection(string VideoId) { public string Url => $"https://www.youtube.com/embed/{VideoId}"; } public partial record YouTubeVideoEmbedProjection { public static YouTubeVideoEmbedProjection? TryResolve(Embed embed) { if (embed.Kind != EmbedKind.Video) return null; if (string.IsNullOrWhiteSpace(embed.Url)) return null; var videoId = YoutubeExplode.Videos.VideoId.TryParse(embed.Url); if (videoId is null) return null; return new YouTubeVideoEmbedProjection(videoId); } }
```

# Discord/Data/Emoji.cs

```cs
using System; using System.Text.Json; using DiscordChatExporter.Core.Discord.Data.Common; using DiscordChatExporter.Core.Utils; using DiscordChatExporter.Core.Utils.Extensions; using JsonExtensions.Reading; namespace DiscordChatExporter.Core.Discord.Data; // https://discord.com/developers/docs/resources/emoji#emoji-object public partial record Emoji( // Only present on custom emoji Snowflake? Id, // Name of a custom emoji (e.g. LUL) or actual representation of a standard emoji (e.g. 🙂) string Name, bool IsAnimated, string ImageUrl ) { // Name of a custom emoji (e.g. LUL) or name of a standard emoji (e.g. slight_smile) public string Code => Id is not null ? Name : EmojiIndex.TryGetCode(Name) ?? Name; } public partial record Emoji { public static string GetImageUrl(Snowflake? id, string? name, bool isAnimated) { // Custom emoji if (id is not null) return ImageCdn.GetCustomEmojiUrl(id.Value, isAnimated); // Standard emoji if (!string.IsNullOrWhiteSpace(name)) return ImageCdn.GetStandardEmojiUrl(name); throw new InvalidOperationException("Either the emoji ID or name should be provided."); } public static Emoji Parse(JsonElement json) { var id = json.GetPropertyOrNull("id") ?.GetNonWhiteSpaceStringOrNull() ?.Pipe(Snowflake.Parse); // Names may be missing on custom emoji within reactions var name = json.GetPropertyOrNull("name")?.GetNonWhiteSpaceStringOrNull() ?? "Unknown Emoji"; var isAnimated = json.GetPropertyOrNull("animated")?.GetBooleanOrNull() ?? false; var imageUrl = GetImageUrl(id, name, isAnimated); return new Emoji(id, name, isAnimated, imageUrl); } }
```

# Discord/Data/Guild.cs

```cs
using System.Text.Json; using DiscordChatExporter.Core.Discord.Data.Common; using DiscordChatExporter.Core.Utils.Extensions; using JsonExtensions.Reading; namespace DiscordChatExporter.Core.Discord.Data; // https://discord.com/developers/docs/resources/guild#guild-object public partial record Guild(Snowflake Id, string Name, string IconUrl) : IHasId { public bool IsDirect => Id == DirectMessages.Id; } public partial record Guild { // Direct messages are encapsulated within a special pseudo-guild for consistency public static Guild DirectMessages { get; } = new(Snowflake.Zero, "Direct Messages", ImageCdn.GetFallbackUserAvatarUrl()); public static Guild Parse(JsonElement json) { var id = json.GetProperty("id").GetNonWhiteSpaceString().Pipe(Snowflake.Parse); var name = json.GetProperty("name").GetNonNullString(); var iconUrl = json.GetPropertyOrNull("icon") ?.GetNonWhiteSpaceStringOrNull() ?.Pipe(h => ImageCdn.GetGuildIconUrl(id, h)) ?? ImageCdn.GetFallbackUserAvatarUrl(); return new Guild(id, name, iconUrl); } }
```

# Discord/Data/Interaction.cs

```cs
using System.Text.Json; using DiscordChatExporter.Core.Utils.Extensions; using JsonExtensions.Reading; namespace DiscordChatExporter.Core.Discord.Data; // https://discord.com/developers/docs/interactions/receiving-and-responding#message-interaction-object public record Interaction(Snowflake Id, string Name, User User) { public static Interaction Parse(JsonElement json) { var id = json.GetProperty("id").GetNonWhiteSpaceString().Pipe(Snowflake.Parse); var name = json.GetProperty("name").GetNonNullString(); // may be empty, but not null var user = json.GetProperty("user").Pipe(User.Parse); return new Interaction(id, name, user); } }
```

# Discord/Data/Invite.cs

```cs
using System.Text.Json; using System.Text.RegularExpressions; using DiscordChatExporter.Core.Utils.Extensions; using JsonExtensions.Reading; namespace DiscordChatExporter.Core.Discord.Data; // https://discord.com/developers/docs/resources/invite#invite-object public record Invite(string Code, Guild Guild, Channel? Channel) { public static string? TryGetCodeFromUrl(string url) => Regex.Match(url, @"^https?://discord\.gg/(\w+)/?$").Groups[1].Value.NullIfWhiteSpace(); public static Invite Parse(JsonElement json) { var code = json.GetProperty("code").GetNonWhiteSpaceString(); var guild = json.GetPropertyOrNull("guild")?.Pipe(Guild.Parse) ?? Guild.DirectMessages; var channel = json.GetPropertyOrNull("channel")?.Pipe(c => Channel.Parse(c)); return new Invite(code, guild, channel); } }
```

# Discord/Data/Member.cs

```cs
using System.Collections.Generic; using System.Linq; using System.Text.Json; using DiscordChatExporter.Core.Discord.Data.Common; using DiscordChatExporter.Core.Utils.Extensions; using JsonExtensions.Reading; namespace DiscordChatExporter.Core.Discord.Data; // https://discord.com/developers/docs/resources/guild#guild-member-object public partial record Member( User User, string? DisplayName, string? AvatarUrl, IReadOnlyList<Snowflake> RoleIds ) : IHasId { public Snowflake Id => User.Id; } public partial record Member { public static Member CreateFallback(User user) => new(user, null, null, []); public static Member Parse(JsonElement json, Snowflake? guildId = null) { var user = json.GetProperty("user").Pipe(User.Parse); var displayName = json.GetPropertyOrNull("nick")?.GetNonWhiteSpaceStringOrNull(); var roleIds = json.GetPropertyOrNull("roles") ?.EnumerateArray() .Select(j => j.GetNonWhiteSpaceString()) .Select(Snowflake.Parse) .ToArray() ?? []; var avatarUrl = guildId is not null ? json.GetPropertyOrNull("avatar") ?.GetNonWhiteSpaceStringOrNull() ?.Pipe(h => ImageCdn.GetMemberAvatarUrl(guildId.Value, user.Id, h)) : null; return new Member(user, displayName, avatarUrl, roleIds); } }
```

# Discord/Data/Message.cs

```cs
using System; using System.Collections.Generic; using System.Linq; using System.Text.Json; using DiscordChatExporter.Core.Discord.Data.Common; using DiscordChatExporter.Core.Discord.Data.Embeds; using DiscordChatExporter.Core.Utils.Extensions; using JsonExtensions.Reading; namespace DiscordChatExporter.Core.Discord.Data; // https://discord.com/developers/docs/resources/channel#message-object public partial record Message( Snowflake Id, MessageKind Kind, MessageFlags Flags, User Author, DateTimeOffset Timestamp, DateTimeOffset? EditedTimestamp, DateTimeOffset? CallEndedTimestamp, bool IsPinned, string Content, IReadOnlyList<Attachment> Attachments, IReadOnlyList<Embed> Embeds, IReadOnlyList<Sticker> Stickers, IReadOnlyList<Reaction> Reactions, IReadOnlyList<User> MentionedUsers, MessageReference? Reference, Message? ReferencedMessage, Interaction? Interaction ) : IHasId { public bool IsSystemNotification => Kind is >= MessageKind.RecipientAdd and <= MessageKind.ThreadCreated; public bool IsReply => Kind == MessageKind.Reply; // App interactions are rendered as replies in the Discord client, but they are not actually replies public bool IsReplyLike => IsReply || Interaction is not null; public bool IsEmpty => string.IsNullOrWhiteSpace(Content) && !Attachments.Any() && !Embeds.Any() && !Stickers.Any(); public IEnumerable<User> GetReferencedUsers() { yield return Author; foreach (var user in MentionedUsers) yield return user; if (ReferencedMessage is not null) yield return ReferencedMessage.Author; if (Interaction is not null) yield return Interaction.User; } } public partial record Message { private static IReadOnlyList<Embed> NormalizeEmbeds(IReadOnlyList<Embed> embeds) { if (embeds.Count <= 1) return embeds; // Discord API doesn't support embeds with multiple images, even though Discord client does. // To work around this, it seems that the API returns multiple consecutive embeds with different images, // which are then merged together on the client. We need to replicate the same behavior ourselves. // Currently, only known case where this workaround is required is Twitter embeds. // https://github.com/Tyrrrz/DiscordChatExporter/issues/695 var normalizedEmbeds = new List<Embed>(); for (var i = 0; i < embeds.Count; i++) { var embed = embeds[i]; if (embed.Url?.Contains("://twitter.com/", StringComparison.OrdinalIgnoreCase) == true) { // Find embeds with the same URL that only contain a single image and nothing else var trailingEmbeds = embeds .Skip(i + 1) .TakeWhile(e => e.Url == embed.Url && e.Timestamp is null && e.Author is null && e.Color is null && string.IsNullOrWhiteSpace(e.Description) && !e.Fields.Any() && e.Images.Count == 1 && e.Footer is null ) .ToArray(); if (trailingEmbeds.Any()) { // Concatenate all images into one embed var images = embed .Images.Concat(trailingEmbeds.SelectMany(e => e.Images)) .ToArray(); normalizedEmbeds.Add(embed with { Images = images }); i += trailingEmbeds.Length; } else { normalizedEmbeds.Add(embed); } } else { normalizedEmbeds.Add(embed); } } return normalizedEmbeds; } public static Message Parse(JsonElement json) { var id = json.GetProperty("id").GetNonWhiteSpaceString().Pipe(Snowflake.Parse); var kind = json.GetProperty("type").GetInt32().Pipe(t => (MessageKind)t); var flags = json.GetPropertyOrNull("flags")?.GetInt32OrNull()?.Pipe(f => (MessageFlags)f) ?? MessageFlags.None; var author = json.GetProperty("author").Pipe(User.Parse); var timestamp = json.GetProperty("timestamp").GetDateTimeOffset(); var editedTimestamp = json.GetPropertyOrNull("edited_timestamp")?.GetDateTimeOffsetOrNull(); var callEndedTimestamp = json.GetPropertyOrNull("call") ?.GetPropertyOrNull("ended_timestamp") ?.GetDateTimeOffsetOrNull(); var isPinned = json.GetPropertyOrNull("pinned")?.GetBooleanOrNull() ?? false; var content = json.GetPropertyOrNull("content")?.GetStringOrNull() ?? ""; var attachments = json.GetPropertyOrNull("attachments") ?.EnumerateArrayOrNull() ?.Select(Attachment.Parse) .ToArray() ?? []; var embeds = NormalizeEmbeds( json.GetPropertyOrNull("embeds")?.EnumerateArrayOrNull()?.Select(Embed.Parse).ToArray() ?? [] ); var stickers = json.GetPropertyOrNull("sticker_items") ?.EnumerateArrayOrNull() ?.Select(Sticker.Parse) .ToArray() ?? []; var reactions = json.GetPropertyOrNull("reactions") ?.EnumerateArrayOrNull() ?.Select(Reaction.Parse) .ToArray() ?? []; var mentionedUsers = json.GetPropertyOrNull("mentions")?.EnumerateArrayOrNull()?.Select(User.Parse).ToArray() ?? []; var messageReference = json.GetPropertyOrNull("message_reference") ?.Pipe(MessageReference.Parse); var referencedMessage = json.GetPropertyOrNull("referenced_message")?.Pipe(Parse); var interaction = json.GetPropertyOrNull("interaction")?.Pipe(Interaction.Parse); return new Message( id, kind, flags, author, timestamp, editedTimestamp, callEndedTimestamp, isPinned, content, attachments, embeds, stickers, reactions, mentionedUsers, messageReference, referencedMessage, interaction ); } }
```

# Discord/Data/MessageFlags.cs

```cs
using System; namespace DiscordChatExporter.Core.Discord.Data; // https://discord.com/developers/docs/resources/channel#message-object-message-flags [Flags] public enum MessageFlags { None = 0, CrossPosted = 1, CrossPost = 2, SuppressEmbeds = 4, SourceMessageDeleted = 8, Urgent = 16, HasThread = 32, Ephemeral = 64, Loading = 128, }
```

# Discord/Data/MessageKind.cs

```cs
namespace DiscordChatExporter.Core.Discord.Data; // https://discord.com/developers/docs/resources/channel#message-object-message-types public enum MessageKind { Default = 0, RecipientAdd = 1, RecipientRemove = 2, Call = 3, ChannelNameChange = 4, ChannelIconChange = 5, ChannelPinnedMessage = 6, GuildMemberJoin = 7, ThreadCreated = 18, Reply = 19, }
```

# Discord/Data/MessageReference.cs

```cs
using System.Text.Json; using DiscordChatExporter.Core.Utils.Extensions; using JsonExtensions.Reading; namespace DiscordChatExporter.Core.Discord.Data; // https://discord.com/developers/docs/resources/channel#message-object-message-reference-structure public record MessageReference(Snowflake? MessageId, Snowflake? ChannelId, Snowflake? GuildId) { public static MessageReference Parse(JsonElement json) { var messageId = json.GetPropertyOrNull("message_id") ?.GetNonWhiteSpaceStringOrNull() ?.Pipe(Snowflake.Parse); var channelId = json.GetPropertyOrNull("channel_id") ?.GetNonWhiteSpaceStringOrNull() ?.Pipe(Snowflake.Parse); var guildId = json.GetPropertyOrNull("guild_id") ?.GetNonWhiteSpaceStringOrNull() ?.Pipe(Snowflake.Parse); return new MessageReference(messageId, channelId, guildId); } }
```

# Discord/Data/Reaction.cs

```cs
using System.Text.Json; using DiscordChatExporter.Core.Utils.Extensions; namespace DiscordChatExporter.Core.Discord.Data; // https://discord.com/developers/docs/resources/channel#reaction-object public record Reaction(Emoji Emoji, int Count) { public static Reaction Parse(JsonElement json) { var emoji = json.GetProperty("emoji").Pipe(Emoji.Parse); var count = json.GetProperty("count").GetInt32(); return new Reaction(emoji, count); } }
```

# Discord/Data/Role.cs

```cs
using System.Drawing; using System.Text.Json; using DiscordChatExporter.Core.Discord.Data.Common; using DiscordChatExporter.Core.Utils.Extensions; using JsonExtensions.Reading; namespace DiscordChatExporter.Core.Discord.Data; // https://discord.com/developers/docs/topics/permissions#role-object public record Role(Snowflake Id, string Name, int Position, Color? Color) : IHasId { public static Role Parse(JsonElement json) { var id = json.GetProperty("id").GetNonWhiteSpaceString().Pipe(Snowflake.Parse); var name = json.GetProperty("name").GetNonNullString(); var position = json.GetProperty("position").GetInt32(); var color = json.GetPropertyOrNull("color") ?.GetInt32OrNull() ?.Pipe(System.Drawing.Color.FromArgb) .ResetAlpha() .NullIf(c => c.ToRgb() <= 0); return new Role(id, name, position, color); } }
```

# Discord/Data/Sticker.cs

```cs
using System; using System.Text.Json; using DiscordChatExporter.Core.Discord.Data.Common; using DiscordChatExporter.Core.Utils.Extensions; using JsonExtensions.Reading; namespace DiscordChatExporter.Core.Discord.Data; // https://discord.com/developers/docs/resources/sticker#sticker-resource public partial record Sticker(Snowflake Id, string Name, StickerFormat Format, string SourceUrl) { public bool IsImage => Format != StickerFormat.Lottie; } public partial record Sticker { public static Sticker Parse(JsonElement json) { var id = json.GetProperty("id").GetNonWhiteSpaceString().Pipe(Snowflake.Parse); var name = json.GetProperty("name").GetNonNullString(); var format = json.GetProperty("format_type").GetInt32().Pipe(t => (StickerFormat)t); var sourceUrl = ImageCdn.GetStickerUrl( id, format switch { StickerFormat.Png => "png", StickerFormat.Apng => "png", StickerFormat.Lottie => "json", StickerFormat.Gif => "gif", _ => throw new InvalidOperationException($"Unknown sticker format '{format}'."), } ); return new Sticker(id, name, format, sourceUrl); } }
```

# Discord/Data/StickerFormat.cs

```cs
namespace DiscordChatExporter.Core.Discord.Data; public enum StickerFormat { Png = 1, Apng = 2, Lottie = 3, Gif = 4, }
```

# Discord/Data/User.cs

```cs
using System.Text.Json; using DiscordChatExporter.Core.Discord.Data.Common; using DiscordChatExporter.Core.Utils.Extensions; using JsonExtensions.Reading; namespace DiscordChatExporter.Core.Discord.Data; // https://discord.com/developers/docs/resources/user#user-object public partial record User( Snowflake Id, bool IsBot, // Remove after Discord migrates all accounts to the new system. // With that, also remove the DiscriminatorFormatted and FullName properties. // Replace existing calls to FullName with Name (not DisplayName). int? Discriminator, string Name, string DisplayName, string AvatarUrl ) : IHasId { public string DiscriminatorFormatted => Discriminator is not null ? $"{Discriminator:0000}" : "0000"; // This effectively represents the user's true identity. // In the old system, this is formed from the username and discriminator. // In the new system, the username is already the user's unique identifier. public string FullName => Discriminator is not null ? $"{Name}#{DiscriminatorFormatted}" : Name; } public partial record User { public static User Parse(JsonElement json) { var id = json.GetProperty("id").GetNonWhiteSpaceString().Pipe(Snowflake.Parse); var isBot = json.GetPropertyOrNull("bot")?.GetBooleanOrNull() ?? false; var discriminator = json.GetPropertyOrNull("discriminator") ?.GetNonWhiteSpaceStringOrNull() ?.Pipe(int.Parse) .NullIfDefault(); var name = json.GetProperty("username").GetNonNullString(); var displayName = json.GetPropertyOrNull("global_name")?.GetNonWhiteSpaceStringOrNull() ?? name; var avatarIndex = discriminator % 5 ?? (int)((id.Value >> 22) % 6); var avatarUrl = json.GetPropertyOrNull("avatar") ?.GetNonWhiteSpaceStringOrNull() ?.Pipe(h => ImageCdn.GetUserAvatarUrl(id, h)) ?? ImageCdn.GetFallbackUserAvatarUrl(avatarIndex); return new User(id, isBot, discriminator, name, displayName, avatarUrl); } }
```

# Discord/DiscordClient.cs

```cs
using System; using System.Collections.Generic; using System.Globalization; using System.Linq; using System.Net; using System.Net.Http; using System.Runtime.CompilerServices; using System.Text.Json; using System.Threading; using System.Threading.Tasks; using DiscordChatExporter.Core.Discord.Data; using DiscordChatExporter.Core.Exceptions; using DiscordChatExporter.Core.Utils; using DiscordChatExporter.Core.Utils.Extensions; using Gress; using JsonExtensions.Http; using JsonExtensions.Reading; namespace DiscordChatExporter.Core.Discord; public class DiscordClient(string token) { private readonly Uri _baseUri = new("https://discord.com/api/v10/", UriKind.Absolute); private TokenKind? _resolvedTokenKind; private async ValueTask<HttpResponseMessage> GetResponseAsync( string url, TokenKind tokenKind, CancellationToken cancellationToken = default ) { return await Http.ResponseResiliencePipeline.ExecuteAsync( async innerCancellationToken => { using var request = new HttpRequestMessage(HttpMethod.Get, new Uri(_baseUri, url)); // Don't validate because the token can have special characters // https://github.com/Tyrrrz/DiscordChatExporter/issues/828 request.Headers.TryAddWithoutValidation( "Authorization", tokenKind == TokenKind.Bot ? $"Bot {token}" : token ); var response = await Http.Client.SendAsync( request, HttpCompletionOption.ResponseHeadersRead, innerCancellationToken ); // If this was the last request available before hitting the rate limit, // wait out the reset time so that future requests can succeed. // This may add an unnecessary delay in case the user doesn't intend to // make any more requests, but implementing a smarter solution would // require properly keeping track of Discord's global/per-route/per-resource // rate limits and that's just way too much effort. // https://discord.com/developers/docs/topics/rate-limits var remainingRequestCount = response .Headers.TryGetValue("X-RateLimit-Remaining") ?.Pipe(s => int.Parse(s, CultureInfo.InvariantCulture)); var resetAfterDelay = response .Headers.TryGetValue("X-RateLimit-Reset-After") ?.Pipe(s => double.Parse(s, CultureInfo.InvariantCulture)) .Pipe(TimeSpan.FromSeconds); if (remainingRequestCount <= 0 && resetAfterDelay is not null) { var delay = // Adding a small buffer to the reset time reduces the chance of getting // rate limited again, because it allows for more requests to be released. (resetAfterDelay.Value + TimeSpan.FromSeconds(1)) // Sometimes Discord returns an absurdly high value for the reset time, which // is not actually enforced by the server. So we cap it at a reasonable value. .Clamp(TimeSpan.Zero, TimeSpan.FromSeconds(60)); await Task.Delay(delay, innerCancellationToken); } return response; }, cancellationToken ); } private async ValueTask<TokenKind> ResolveTokenKindAsync( CancellationToken cancellationToken = default ) { if (_resolvedTokenKind is not null) return _resolvedTokenKind.Value; // Try authenticating as a user using var userResponse = await GetResponseAsync( "users/@me", TokenKind.User, cancellationToken ); if (userResponse.StatusCode != HttpStatusCode.Unauthorized) return (_resolvedTokenKind = TokenKind.User).Value; // Try authenticating as a bot using var botResponse = await GetResponseAsync( "users/@me", TokenKind.Bot, cancellationToken ); if (botResponse.StatusCode != HttpStatusCode.Unauthorized) return (_resolvedTokenKind = TokenKind.Bot).Value; throw new DiscordChatExporterException("Authentication token is invalid.", true); } private async ValueTask<HttpResponseMessage> GetResponseAsync( string url, CancellationToken cancellationToken = default ) => await GetResponseAsync( url, await ResolveTokenKindAsync(cancellationToken), cancellationToken ); private async ValueTask<JsonElement> GetJsonResponseAsync( string url, CancellationToken cancellationToken = default ) { using var response = await GetResponseAsync(url, cancellationToken); if (!response.IsSuccessStatusCode) { throw response.StatusCode switch { HttpStatusCode.Unauthorized => throw new DiscordChatExporterException( "Authentication token is invalid.", true ), HttpStatusCode.Forbidden => throw new DiscordChatExporterException( $"Request to '{url}' failed: forbidden." ), HttpStatusCode.NotFound => throw new DiscordChatExporterException( $"Request to '{url}' failed: not found." ), _ => throw new DiscordChatExporterException( $""" Request to '{url}' failed: {response .StatusCode.ToString() .ToSpaceSeparatedWords() .ToLowerInvariant()}. Response content: {await response.Content.ReadAsStringAsync( cancellationToken )} """, true ), }; } return await response.Content.ReadAsJsonAsync(cancellationToken); } private async ValueTask<JsonElement?> TryGetJsonResponseAsync( string url, CancellationToken cancellationToken = default ) { using var response = await GetResponseAsync(url, cancellationToken); return response.IsSuccessStatusCode ? await response.Content.ReadAsJsonAsync(cancellationToken) : null; } public async ValueTask<Application> GetApplicationAsync( CancellationToken cancellationToken = default ) { var response = await GetJsonResponseAsync("applications/@me", cancellationToken); return Application.Parse(response); } public async ValueTask<User?> TryGetUserAsync( Snowflake userId, CancellationToken cancellationToken = default ) { var response = await TryGetJsonResponseAsync($"users/{userId}", cancellationToken); return response?.Pipe(User.Parse); } public async IAsyncEnumerable<Guild> GetUserGuildsAsync( [EnumeratorCancellation] CancellationToken cancellationToken = default ) { yield return Guild.DirectMessages; var currentAfter = Snowflake.Zero; while (true) { var url = new UrlBuilder() .SetPath("users/@me/guilds") .SetQueryParameter("limit", "100") .SetQueryParameter("after", currentAfter.ToString()) .Build(); var response = await GetJsonResponseAsync(url, cancellationToken); var count = 0; foreach (var guildJson in response.EnumerateArray()) { var guild = Guild.Parse(guildJson); yield return guild; currentAfter = guild.Id; count++; } if (count <= 0) yield break; } } public async ValueTask<Guild> GetGuildAsync( Snowflake guildId, CancellationToken cancellationToken = default ) { if (guildId == Guild.DirectMessages.Id) return Guild.DirectMessages; var response = await GetJsonResponseAsync($"guilds/{guildId}", cancellationToken); return Guild.Parse(response); } public async IAsyncEnumerable<Channel> GetGuildChannelsAsync( Snowflake guildId, [EnumeratorCancellation] CancellationToken cancellationToken = default ) { if (guildId == Guild.DirectMessages.Id) { var response = await GetJsonResponseAsync("users/@me/channels", cancellationToken); foreach (var channelJson in response.EnumerateArray()) yield return Channel.Parse(channelJson); } else { var response = await GetJsonResponseAsync( $"guilds/{guildId}/channels", cancellationToken ); var channelsJson = response .EnumerateArray() .OrderBy(j => j.GetProperty("position").GetInt32()) .ThenBy(j => j.GetProperty("id").GetNonWhiteSpaceString().Pipe(Snowflake.Parse)) .ToArray(); var parentsById = channelsJson .Where(j => j.GetProperty("type").GetInt32() == (int)ChannelKind.GuildCategory) .Select((j, i) => Channel.Parse(j, null, i + 1)) .ToDictionary(j => j.Id); // Discord channel positions are relative, so we need to normalize them // so that the user may refer to them more easily in file name templates. var position = 0; foreach (var channelJson in channelsJson) { var parent = channelJson .GetPropertyOrNull("parent_id") ?.GetNonWhiteSpaceStringOrNull() ?.Pipe(Snowflake.Parse) .Pipe(parentsById.GetValueOrDefault); yield return Channel.Parse(channelJson, parent, position); position++; } } } public async IAsyncEnumerable<Channel> GetGuildThreadsAsync( Snowflake guildId, bool includeArchived = false, Snowflake? before = null, Snowflake? after = null, [EnumeratorCancellation] CancellationToken cancellationToken = default ) { if (guildId == Guild.DirectMessages.Id) yield break; var channels = (await GetGuildChannelsAsync(guildId, cancellationToken)) // Categories cannot have threads .Where(c => !c.IsCategory) // Voice channels cannot have threads .Where(c => !c.IsVoice) // Empty channels cannot have threads .Where(c => !c.IsEmpty) // If the 'before' boundary is specified, skip channels that don't have messages // for that range, because thread-start event should always be accompanied by a message. // Note that we don't perform a similar check for the 'after' boundary, because // threads may have messages in range, even if the parent channel doesn't. .Where(c => before is null || c.MayHaveMessagesBefore(before.Value)) .ToArray(); // User accounts can only fetch threads using the search endpoint if (await ResolveTokenKindAsync(cancellationToken) == TokenKind.User) { // Active threads foreach (var channel in channels) { var currentOffset = 0; while (true) { var url = new UrlBuilder() .SetPath($"channels/{channel.Id}/threads/search") .SetQueryParameter("sort_by", "last_message_time") .SetQueryParameter("sort_order", "desc") .SetQueryParameter("archived", "false") .SetQueryParameter("offset", currentOffset.ToString()) .Build(); // Can be null on channels that the user cannot access or channels without threads var response = await TryGetJsonResponseAsync(url, cancellationToken); if (response is null) break; var breakOuter = false; foreach ( var threadJson in response.Value.GetProperty("threads").EnumerateArray() ) { var thread = Channel.Parse(threadJson, channel); // If the 'after' boundary is specified, we can break early, // because threads are sorted by last message time. if (after is not null && !thread.MayHaveMessagesAfter(after.Value)) { breakOuter = true; break; } yield return thread; currentOffset++; } if (breakOuter) break; if (!response.Value.GetProperty("has_more").GetBoolean()) break; } } // Archived threads if (includeArchived) { foreach (var channel in channels) { var currentOffset = 0; while (true) { var url = new UrlBuilder() .SetPath($"channels/{channel.Id}/threads/search") .SetQueryParameter("sort_by", "last_message_time") .SetQueryParameter("sort_order", "desc") .SetQueryParameter("archived", "true") .SetQueryParameter("offset", currentOffset.ToString()) .Build(); // Can be null on channels that the user cannot access or channels without threads var response = await TryGetJsonResponseAsync(url, cancellationToken); if (response is null) break; var breakOuter = false; foreach ( var threadJson in response.Value.GetProperty("threads").EnumerateArray() ) { var thread = Channel.Parse(threadJson, channel); // If the 'after' boundary is specified, we can break early, // because threads are sorted by last message time. if (after is not null && !thread.MayHaveMessagesAfter(after.Value)) { breakOuter = true; break; } yield return thread; currentOffset++; } if (breakOuter) break; if (!response.Value.GetProperty("has_more").GetBoolean()) break; } } } } // Bot accounts can only fetch threads using the threads endpoint else { // Active threads { var parentsById = channels.ToDictionary(c => c.Id); var response = await GetJsonResponseAsync( $"guilds/{guildId}/threads/active", cancellationToken ); foreach (var threadJson in response.GetProperty("threads").EnumerateArray()) { var parent = threadJson .GetPropertyOrNull("parent_id") ?.GetNonWhiteSpaceStringOrNull() ?.Pipe(Snowflake.Parse) .Pipe(parentsById.GetValueOrDefault); yield return Channel.Parse(threadJson, parent); } } // Archived threads if (includeArchived) { foreach (var channel in channels) { // Public archived threads { // Can be null on certain channels var response = await TryGetJsonResponseAsync( $"channels/{channel.Id}/threads/archived/public", cancellationToken ); if (response is null) continue; foreach ( var threadJson in response.Value.GetProperty("threads").EnumerateArray() ) yield return Channel.Parse(threadJson, channel); } // Private archived threads { // Can be null on certain channels var response = await TryGetJsonResponseAsync( $"channels/{channel.Id}/threads/archived/private", cancellationToken ); if (response is null) continue; foreach ( var threadJson in response.Value.GetProperty("threads").EnumerateArray() ) yield return Channel.Parse(threadJson, channel); } } } } } public async IAsyncEnumerable<Role> GetGuildRolesAsync( Snowflake guildId, [EnumeratorCancellation] CancellationToken cancellationToken = default ) { if (guildId == Guild.DirectMessages.Id) yield break; var response = await GetJsonResponseAsync($"guilds/{guildId}/roles", cancellationToken); foreach (var roleJson in response.EnumerateArray()) yield return Role.Parse(roleJson); } public async ValueTask<Member?> TryGetGuildMemberAsync( Snowflake guildId, Snowflake memberId, CancellationToken cancellationToken = default ) { if (guildId == Guild.DirectMessages.Id) return null; var response = await TryGetJsonResponseAsync( $"guilds/{guildId}/members/{memberId}", cancellationToken ); return response?.Pipe(j => Member.Parse(j, guildId)); } public async ValueTask<Invite?> TryGetInviteAsync( string code, CancellationToken cancellationToken = default ) { var response = await TryGetJsonResponseAsync($"invites/{code}", cancellationToken); return response?.Pipe(Invite.Parse); } public async ValueTask<Channel> GetChannelAsync( Snowflake channelId, CancellationToken cancellationToken = default ) { var response = await GetJsonResponseAsync($"channels/{channelId}", cancellationToken); var parentId = response .GetPropertyOrNull("parent_id") ?.GetNonWhiteSpaceStringOrNull() ?.Pipe(Snowflake.Parse); try { var parent = parentId is not null ? await GetChannelAsync(parentId.Value, cancellationToken) : null; return Channel.Parse(response, parent); } // It's possible for the parent channel to be inaccessible, despite the // child channel being accessible. // https://github.com/Tyrrrz/DiscordChatExporter/issues/1108 catch (DiscordChatExporterException) { return Channel.Parse(response); } } private async ValueTask<Message?> TryGetLastMessageAsync( Snowflake channelId, Snowflake? before = null, CancellationToken cancellationToken = default ) { var url = new UrlBuilder() .SetPath($"channels/{channelId}/messages") .SetQueryParameter("limit", "1") .SetQueryParameter("before", before?.ToString()) .Build(); var response = await GetJsonResponseAsync(url, cancellationToken); return response.EnumerateArray().Select(Message.Parse).LastOrDefault(); } public async IAsyncEnumerable<Message> GetMessagesAsync( Snowflake channelId, Snowflake? after = null, Snowflake? before = null, IProgress<Percentage>? progress = null, [EnumeratorCancellation] CancellationToken cancellationToken = default ) { // Get the last message in the specified range, so we can later calculate the // progress based on the difference between message timestamps. // This also snapshots the boundaries, which means that messages posted after // the export started will not appear in the output. var lastMessage = await TryGetLastMessageAsync(channelId, before, cancellationToken); if (lastMessage is null || lastMessage.Timestamp < after?.ToDate()) yield break; // Keep track of the first message in range in order to calculate the progress var firstMessage = default(Message); var currentAfter = after ?? Snowflake.Zero; while (true) { var url = new UrlBuilder() .SetPath($"channels/{channelId}/messages") .SetQueryParameter("limit", "100") .SetQueryParameter("after", currentAfter.ToString()) .Build(); var response = await GetJsonResponseAsync(url, cancellationToken); var messages = response .EnumerateArray() .Select(Message.Parse) // Messages are returned from newest to oldest, so we need to reverse them .Reverse() .ToArray(); // Break if there are no messages (can happen if messages are deleted during execution) if (!messages.Any()) yield break; // If all messages are empty, make sure that it's not because the bot account doesn't // have the Message Content Intent enabled. // https://github.com/Tyrrrz/DiscordChatExporter/issues/1106#issuecomment-1741548959 if ( messages.All(m => m.IsEmpty) && await ResolveTokenKindAsync(cancellationToken) == TokenKind.Bot ) { var application = await GetApplicationAsync(cancellationToken); if (!application.IsMessageContentIntentEnabled) { throw new DiscordChatExporterException( "Provided bot account does not have the Message Content Intent enabled.", true ); } } foreach (var message in messages) { firstMessage ??= message; // Ensure that the messages are in range if (message.Timestamp > lastMessage.Timestamp) yield break; // Report progress based on timestamps if (progress is not null) { var exportedDuration = (message.Timestamp - firstMessage.Timestamp).Duration(); var totalDuration = (lastMessage.Timestamp - firstMessage.Timestamp).Duration(); progress.Report( Percentage.FromFraction( // Avoid division by zero if all messages have the exact same timestamp // (which happens when there's only one message in the channel) totalDuration > TimeSpan.Zero ? exportedDuration / totalDuration : 1 ) ); } yield return message; currentAfter = message.Id; } } } public async IAsyncEnumerable<User> GetMessageReactionsAsync( Snowflake channelId, Snowflake messageId, Emoji emoji, [EnumeratorCancellation] CancellationToken cancellationToken = default ) { var reactionName = emoji.Id is not null // Custom emoji ? emoji.Name + ':' + emoji.Id // Standard emoji : emoji.Name; var currentAfter = Snowflake.Zero; while (true) { var url = new UrlBuilder() .SetPath( $"channels/{channelId}/messages/{messageId}/reactions/{Uri.EscapeDataString(reactionName)}" ) .SetQueryParameter("limit", "100") .SetQueryParameter("after", currentAfter.ToString()) .Build(); // Can be null on reactions with an emoji that has been deleted (?) // https://github.com/Tyrrrz/DiscordChatExporter/issues/1226 var response = await TryGetJsonResponseAsync(url, cancellationToken); if (response is null) yield break; var count = 0; foreach (var userJson in response.Value.EnumerateArray()) { var user = User.Parse(userJson); yield return user; currentAfter = user.Id; count++; } // Each batch can contain up to 100 users. // If we got fewer, then it's definitely the last batch. if (count < 100) yield break; } } }
```

# Discord/Dump/DataDump.cs

```cs
using System; using System.Collections.Generic; using System.IO.Compression; using System.Text.Json; using System.Threading; using System.Threading.Tasks; using JsonExtensions.Reading; namespace DiscordChatExporter.Core.Discord.Dump; public partial class DataDump(IReadOnlyList<DataDumpChannel> channels) { public IReadOnlyList<DataDumpChannel> Channels { get; } = channels; } public partial class DataDump { public static DataDump Parse(JsonElement json) { var channels = new List<DataDumpChannel>(); foreach (var property in json.EnumerateObjectOrEmpty()) { var channelId = Snowflake.Parse(property.Name); var channelName = property.Value.GetString(); // Null items refer to deleted channels if (channelName is null) continue; var channel = new DataDumpChannel(channelId, channelName); channels.Add(channel); } return new DataDump(channels); } public static async ValueTask<DataDump> LoadAsync( string zipFilePath, CancellationToken cancellationToken = default ) { using var archive = ZipFile.OpenRead(zipFilePath); var entry = archive.GetEntry("messages/index.json"); if (entry is null) { throw new InvalidOperationException( "Failed to locate the channel index inside the data package." ); } await using var stream = entry.Open(); using var document = await JsonDocument.ParseAsync(stream, default, cancellationToken); return Parse(document.RootElement); } }
```

# Discord/Dump/DataDumpChannel.cs

```cs
namespace DiscordChatExporter.Core.Discord.Dump; public record DataDumpChannel(Snowflake Id, string Name);
```

# Discord/Snowflake.cs

```cs
using System; using System.Diagnostics.CodeAnalysis; using System.Globalization; namespace DiscordChatExporter.Core.Discord; public readonly partial record struct Snowflake(ulong Value) { public DateTimeOffset ToDate() => DateTimeOffset .FromUnixTimeMilliseconds((long)((Value >> 22) + 1420070400000UL)) .ToLocalTime(); [ExcludeFromCodeCoverage] public override string ToString() => Value.ToString(CultureInfo.InvariantCulture); } public partial record struct Snowflake { public static Snowflake Zero { get; } = new(0); public static Snowflake FromDate(DateTimeOffset instant) => new(((ulong)instant.ToUnixTimeMilliseconds() - 1420070400000UL) << 22); public static Snowflake? TryParse(string? value, IFormatProvider? formatProvider = null) { if (string.IsNullOrWhiteSpace(value)) return null; // As number if (ulong.TryParse(value, NumberStyles.None, formatProvider, out var number)) return new Snowflake(number); // As date if (DateTimeOffset.TryParse(value, formatProvider, DateTimeStyles.None, out var instant)) return FromDate(instant); return null; } public static Snowflake Parse(string value, IFormatProvider? formatProvider) => TryParse(value, formatProvider) ?? throw new FormatException($"Invalid snowflake '{value}'."); public static Snowflake Parse(string value) => Parse(value, null); } public partial record struct Snowflake : IComparable<Snowflake>, IComparable { public int CompareTo(Snowflake other) => Value.CompareTo(other.Value); public int CompareTo(object? obj) { if (obj is not Snowflake other) throw new ArgumentException($"Object must be of type {nameof(Snowflake)}."); return Value.CompareTo(other.Value); } public static bool operator >(Snowflake left, Snowflake right) => left.CompareTo(right) > 0; public static bool operator <(Snowflake left, Snowflake right) => left.CompareTo(right) < 0; }
```

# Discord/TokenKind.cs

```cs
namespace DiscordChatExporter.Core.Discord; public enum TokenKind { User, Bot, }
```

# DiscordChatExporter.Core.csproj

```csproj
<Project Sdk="Microsoft.NET.Sdk"> <ItemGroup> <PackageReference Include="AsyncKeyedLock" Version="7.0.1" /> <PackageReference Include="CSharpier.MsBuild" Version="0.29.2" PrivateAssets="all" /> <PackageReference Include="Gress" Version="2.1.1" /> <PackageReference Include="JsonExtensions" Version="1.2.0" /> <PackageReference Include="Polly" Version="8.4.2" /> <PackageReference Include="RazorBlade" Version="0.6.0" /> <PackageReference Include="Superpower" Version="3.0.0" /> <PackageReference Include="WebMarkupMin.Core" Version="2.17.0" /> <PackageReference Include="YoutubeExplode" Version="6.4.2" /> </ItemGroup> </Project>
```

# DiscordChatExporter.Core.sln

```sln
Microsoft Visual Studio Solution File, Format Version 12.00 # Visual Studio Version 17 VisualStudioVersion = 17.5.002.0 MinimumVisualStudioVersion = 10.0.40219.1 Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "DiscordChatExporter.Core", "DiscordChatExporter.Core.csproj", "{449903C0-F6FE-4446-AC51-17FDC1A6F68A}" EndProject Global GlobalSection(SolutionConfigurationPlatforms) = preSolution Debug|Any CPU = Debug|Any CPU Release|Any CPU = Release|Any CPU EndGlobalSection GlobalSection(ProjectConfigurationPlatforms) = postSolution {449903C0-F6FE-4446-AC51-17FDC1A6F68A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU {449903C0-F6FE-4446-AC51-17FDC1A6F68A}.Debug|Any CPU.Build.0 = Debug|Any CPU {449903C0-F6FE-4446-AC51-17FDC1A6F68A}.Release|Any CPU.ActiveCfg = Release|Any CPU {449903C0-F6FE-4446-AC51-17FDC1A6F68A}.Release|Any CPU.Build.0 = Release|Any CPU EndGlobalSection GlobalSection(SolutionProperties) = preSolution HideSolutionNode = FALSE EndGlobalSection GlobalSection(ExtensibilityGlobals) = postSolution SolutionGuid = {31AF791D-EC72-4430-B3CD-AD4FE59B9CDF} EndGlobalSection EndGlobal
```

# Exceptions/DiscordChatExporterException.cs

```cs
using System; namespace DiscordChatExporter.Core.Exceptions; public class DiscordChatExporterException( string message, bool isFatal = false, Exception? innerException = null ) : Exception(message, innerException) { public bool IsFatal { get; } = isFatal; }
```

# Exporting/ChannelExporter.cs

```cs
using System; using System.Threading; using System.Threading.Tasks; using DiscordChatExporter.Core.Discord; using DiscordChatExporter.Core.Discord.Data; using DiscordChatExporter.Core.Exceptions; using Gress; namespace DiscordChatExporter.Core.Exporting; public class ChannelExporter(DiscordClient discord) { public async ValueTask ExportChannelAsync( ExportRequest request, IProgress<Percentage>? progress = null, CancellationToken cancellationToken = default ) { // Forum channels don't have messages, they are just a list of threads if (request.Channel.Kind == ChannelKind.GuildForum) { throw new DiscordChatExporterException( $"Channel '{request.Channel.Name}' " + $"of guild '{request.Guild.Name}' " + $"is a forum and cannot be exported directly. " + "You need to pull its threads and export them individually." ); } // Check if the channel is empty if (request.Channel.IsEmpty) { throw new DiscordChatExporterException( $"Channel '{request.Channel.Name}' " + $"of guild '{request.Guild.Name}' " + $"does not contain any messages." ); } // Check if the 'after' boundary is valid if (request.After is not null && !request.Channel.MayHaveMessagesAfter(request.After.Value)) { throw new DiscordChatExporterException( $"Channel '{request.Channel.Name}' " + $"of guild '{request.Guild.Name}' " + $"does not contain any messages within the specified period." ); } // Check if the 'before' boundary is valid if ( request.Before is not null && !request.Channel.MayHaveMessagesBefore(request.Before.Value) ) { throw new DiscordChatExporterException( $"Channel '{request.Channel.Name}' " + $"of guild '{request.Guild.Name}' " + $"does not contain any messages within the specified period." ); } // Build context var context = new ExportContext(discord, request); await context.PopulateChannelsAndRolesAsync(cancellationToken); // Export messages await using var messageExporter = new MessageExporter(context); await foreach ( var message in discord.GetMessagesAsync( request.Channel.Id, request.After, request.Before, progress, cancellationToken ) ) { try { // Resolve members for referenced users foreach (var user in message.GetReferencedUsers()) await context.PopulateMemberAsync(user, cancellationToken); // Export the message if (request.MessageFilter.IsMatch(message)) await messageExporter.ExportMessageAsync(message, cancellationToken); } catch (Exception ex) { // Provide more context to the exception, to simplify debugging based on error messages throw new DiscordChatExporterException( $"Failed to export message #{message.Id} " + $"in channel '{request.Channel.Name}' (#{request.Channel.Id}) " + $"of guild '{request.Guild.Name} (#{request.Guild.Id})'.", ex is not DiscordChatExporterException dex || dex.IsFatal, ex ); } } // Throw if no messages were exported if (messageExporter.MessagesExported <= 0) { throw new DiscordChatExporterException( $"Channel '{request.Channel.Name}' (#{request.Channel.Id}) " + $"of guild '{request.Guild.Name}' (#{request.Guild.Id}) " + $"does not contain any matching messages within the specified period." ); } } }
```

# Exporting/CsvMessageWriter.cs

```cs
using System; using System.Collections.Generic; using System.IO; using System.Text; using System.Threading; using System.Threading.Tasks; using DiscordChatExporter.Core.Discord.Data; using DiscordChatExporter.Core.Utils.Extensions; namespace DiscordChatExporter.Core.Exporting; internal partial class CsvMessageWriter(Stream stream, ExportContext context) : MessageWriter(stream, context) { private readonly TextWriter _writer = new StreamWriter(stream); private async ValueTask<string> FormatMarkdownAsync( string markdown, CancellationToken cancellationToken = default ) => Context.Request.ShouldFormatMarkdown ? await PlainTextMarkdownVisitor.FormatAsync(Context, markdown, cancellationToken) : markdown; public override async ValueTask WritePreambleAsync( CancellationToken cancellationToken = default ) => await _writer.WriteLineAsync("AuthorID,Author,Date,Content,Attachments,Reactions"); private async ValueTask WriteAttachmentsAsync( IReadOnlyList<Attachment> attachments, CancellationToken cancellationToken = default ) { var buffer = new StringBuilder(); foreach (var attachment in attachments) { cancellationToken.ThrowIfCancellationRequested(); buffer .AppendIfNotEmpty(',') .Append(await Context.ResolveAssetUrlAsync(attachment.Url, cancellationToken)); } await _writer.WriteAsync(CsvEncode(buffer.ToString())); } private async ValueTask WriteReactionsAsync( IReadOnlyList<Reaction> reactions, CancellationToken cancellationToken = default ) { var buffer = new StringBuilder(); foreach (var reaction in reactions) { cancellationToken.ThrowIfCancellationRequested(); buffer .AppendIfNotEmpty(',') .Append(reaction.Emoji.Name) .Append(' ') .Append('(') .Append(reaction.Count) .Append(')'); } await _writer.WriteAsync(CsvEncode(buffer.ToString())); } public override async ValueTask WriteMessageAsync( Message message, CancellationToken cancellationToken = default ) { await base.WriteMessageAsync(message, cancellationToken); // Author ID await _writer.WriteAsync(CsvEncode(message.Author.Id.ToString())); await _writer.WriteAsync(','); // Author name await _writer.WriteAsync(CsvEncode(message.Author.FullName)); await _writer.WriteAsync(','); // Message timestamp await _writer.WriteAsync(CsvEncode(Context.FormatDate(message.Timestamp, "o"))); await _writer.WriteAsync(','); // Message content if (message.IsSystemNotification) { await _writer.WriteAsync(CsvEncode(message.GetFallbackContent())); } else { await _writer.WriteAsync( CsvEncode(await FormatMarkdownAsync(message.Content, cancellationToken)) ); } await _writer.WriteAsync(','); // Attachments await WriteAttachmentsAsync(message.Attachments, cancellationToken); await _writer.WriteAsync(','); // Reactions await WriteReactionsAsync(message.Reactions, cancellationToken); // Finish row await _writer.WriteLineAsync(); } public override async ValueTask DisposeAsync() { await _writer.DisposeAsync(); await base.DisposeAsync(); } } internal partial class CsvMessageWriter { private static string CsvEncode(string value) { value = value.Replace("\"", "\"\"", StringComparison.Ordinal); return $"\"{value}\""; } }
```

# Exporting/ExportAssetDownloader.cs

```cs
using System; using System.Collections.Generic; using System.Globalization; using System.IO; using System.Security.Cryptography; using System.Text; using System.Text.RegularExpressions; using System.Threading; using System.Threading.Tasks; using System.Web; using AsyncKeyedLock; using DiscordChatExporter.Core.Utils; using DiscordChatExporter.Core.Utils.Extensions; namespace DiscordChatExporter.Core.Exporting; internal partial class ExportAssetDownloader(string workingDirPath, bool reuse) { private static readonly AsyncKeyedLocker<string> Locker = new(); // File paths of the previously downloaded assets private readonly Dictionary<string, string> _previousPathsByUrl = new(StringComparer.Ordinal); public async ValueTask<string> DownloadAsync( string url, CancellationToken cancellationToken = default ) { var fileName = GetFileNameFromUrl(url); var filePath = Path.Combine(workingDirPath, fileName); using var _ = await Locker.LockAsync(filePath, cancellationToken); if (_previousPathsByUrl.TryGetValue(url, out var cachedFilePath)) return cachedFilePath; // Reuse existing files if we're allowed to if (reuse && File.Exists(filePath)) return _previousPathsByUrl[url] = filePath; Directory.CreateDirectory(workingDirPath); await Http.ResiliencePipeline.ExecuteAsync( async innerCancellationToken => { // Download the file using var response = await Http.Client.GetAsync(url, innerCancellationToken); await using (var output = File.Create(filePath)) await response.Content.CopyToAsync(output, innerCancellationToken); // Try to set the file date according to the last-modified header try { var lastModified = response .Content.Headers.TryGetValue("Last-Modified") ?.Pipe(s => DateTimeOffset.TryParse( s, CultureInfo.InvariantCulture, DateTimeStyles.None, out var instant ) ? instant : (DateTimeOffset?)null ); if (lastModified is not null) { File.SetCreationTimeUtc(filePath, lastModified.Value.UtcDateTime); File.SetLastWriteTimeUtc(filePath, lastModified.Value.UtcDateTime); File.SetLastAccessTimeUtc(filePath, lastModified.Value.UtcDateTime); } } catch { // This can apparently fail for some reason. // Updating the file date is not a critical task, so we'll just ignore exceptions thrown here. // https://github.com/Tyrrrz/DiscordChatExporter/issues/585 } }, cancellationToken ); return _previousPathsByUrl[url] = filePath; } } internal partial class ExportAssetDownloader { private static string GetUrlHash(string url) { // Remove signature parameters from Discord CDN URLs to normalize them static string NormalizeUrl(string url) { var uri = new Uri(url); if (!string.Equals(uri.Host, "cdn.discordapp.com", StringComparison.OrdinalIgnoreCase)) return url; var query = HttpUtility.ParseQueryString(uri.Query); query.Remove("ex"); query.Remove("is"); query.Remove("hm"); return uri.GetLeftPart(UriPartial.Path) + query; } return SHA256 .HashData(Encoding.UTF8.GetBytes(NormalizeUrl(url))) .ToHex() // 5 chars ought to be enough for anybody .Truncate(5); } private static string GetFileNameFromUrl(string url) { var urlHash = GetUrlHash(url); // Try to extract the file name from URL var fileName = Regex.Match(url, @".+/([^?]*)").Groups[1].Value; // If it's not there, just use the URL hash as the file name if (string.IsNullOrWhiteSpace(fileName)) return urlHash; // Otherwise, use the original file name but inject the hash in the middle var fileNameWithoutExtension = Path.GetFileNameWithoutExtension(fileName); var fileExtension = Path.GetExtension(fileName); // Probably not a file extension, just a dot in a long file name // https://github.com/Tyrrrz/DiscordChatExporter/pull/812 if (fileExtension.Length > 41) { fileNameWithoutExtension = fileName; fileExtension = ""; } return PathEx.EscapeFileName( fileNameWithoutExtension.Truncate(42) + '-' + urlHash + fileExtension ); } }
```

# Exporting/ExportContext.cs

```cs
using System; using System.Collections.Generic; using System.Drawing; using System.IO; using System.Linq; using System.Net.Http; using System.Threading; using System.Threading.Tasks; using DiscordChatExporter.Core.Discord; using DiscordChatExporter.Core.Discord.Data; using DiscordChatExporter.Core.Utils.Extensions; namespace DiscordChatExporter.Core.Exporting; public class ExportContext(DiscordClient discord, ExportRequest request) { private readonly Dictionary<Snowflake, Member?> _membersById = new(); private readonly Dictionary<Snowflake, Channel> _channelsById = new(); private readonly Dictionary<Snowflake, Role> _rolesById = new(); private readonly ExportAssetDownloader _assetDownloader = new(request.AssetsDirPath, request.ShouldReuseAssets); public DiscordClient Discord { get; } = discord; public ExportRequest Request { get; } = request; public DateTimeOffset NormalizeDate(DateTimeOffset instant) => Request.IsUtcNormalizationEnabled ? instant.ToUniversalTime() : instant.ToLocalTime(); public string FormatDate(DateTimeOffset instant, string format = "g") => NormalizeDate(instant).ToString(format, Request.CultureInfo); public async ValueTask PopulateChannelsAndRolesAsync( CancellationToken cancellationToken = default ) { await foreach ( var channel in Discord.GetGuildChannelsAsync(Request.Guild.Id, cancellationToken) ) { _channelsById[channel.Id] = channel; } await foreach (var role in Discord.GetGuildRolesAsync(Request.Guild.Id, cancellationToken)) { _rolesById[role.Id] = role; } } // Because members cannot be pulled in bulk, we need to populate them on demand private async ValueTask PopulateMemberAsync( Snowflake id, User? fallbackUser, CancellationToken cancellationToken = default ) { if (_membersById.ContainsKey(id)) return; var member = await Discord.TryGetGuildMemberAsync(Request.Guild.Id, id, cancellationToken); // User may have left the guild since they were mentioned. // Create a dummy member object based on the user info. if (member is null) { var user = fallbackUser ?? await Discord.TryGetUserAsync(id, cancellationToken); // User may have been deleted since they were mentioned if (user is not null) member = Member.CreateFallback(user); } // Store the result even if it's null, to avoid re-fetching non-existing members _membersById[id] = member; } public async ValueTask PopulateMemberAsync( Snowflake id, CancellationToken cancellationToken = default ) => await PopulateMemberAsync(id, null, cancellationToken); public async ValueTask PopulateMemberAsync( User user, CancellationToken cancellationToken = default ) => await PopulateMemberAsync(user.Id, user, cancellationToken); public Member? TryGetMember(Snowflake id) => _membersById.GetValueOrDefault(id); public Channel? TryGetChannel(Snowflake id) => _channelsById.GetValueOrDefault(id); public Role? TryGetRole(Snowflake id) => _rolesById.GetValueOrDefault(id); public IReadOnlyList<Role> GetUserRoles(Snowflake id) => TryGetMember(id) ?.RoleIds.Select(TryGetRole) .WhereNotNull() .OrderByDescending(r => r.Position) .ToArray() ?? []; public Color? TryGetUserColor(Snowflake id) => GetUserRoles(id).Where(r => r.Color is not null).Select(r => r.Color).FirstOrDefault(); public async ValueTask<string> ResolveAssetUrlAsync( string url, CancellationToken cancellationToken = default ) { if (!Request.ShouldDownloadAssets) return url; try { var filePath = await _assetDownloader.DownloadAsync(url, cancellationToken); var relativeFilePath = Path.GetRelativePath(Request.OutputDirPath, filePath); // Prefer the relative path so that the export package can be copied around without breaking references. // However, if the assets directory lies outside of the export directory, use the absolute path instead. var shouldUseAbsoluteFilePath = relativeFilePath.StartsWith( ".." + Path.DirectorySeparatorChar, StringComparison.Ordinal ) || relativeFilePath.StartsWith( ".." + Path.AltDirectorySeparatorChar, StringComparison.Ordinal ); var optimalFilePath = shouldUseAbsoluteFilePath ? filePath : relativeFilePath; // For HTML, the path needs to be properly formatted if (Request.Format is ExportFormat.HtmlDark or ExportFormat.HtmlLight) { // Format the path into a valid file URI var href = new Uri(new Uri("file:///"), optimalFilePath).ToString(); // File schema does not support relative paths, so strip it if that's the case // https://github.com/Tyrrrz/DiscordChatExporter/issues/1155 return shouldUseAbsoluteFilePath ? href : href[8..]; } return optimalFilePath; } // Try to catch only exceptions related to failed HTTP requests // https://github.com/Tyrrrz/DiscordChatExporter/issues/332 // https://github.com/Tyrrrz/DiscordChatExporter/issues/372 catch (Exception ex) when (ex is HttpRequestException or OperationCanceledException) { // We don't want this to crash the exporting process in case of failure. // TODO: add logging so we can be more liberal with catching exceptions. return url; } } }
```

# Exporting/ExportFormat.cs

```cs
using System; namespace DiscordChatExporter.Core.Exporting; public enum ExportFormat { PlainText, HtmlDark, HtmlLight, Csv, Json, } public static class ExportFormatExtensions { public static string GetFileExtension(this ExportFormat format) => format switch { ExportFormat.PlainText => "txt", ExportFormat.HtmlDark => "html", ExportFormat.HtmlLight => "html", ExportFormat.Csv => "csv", ExportFormat.Json => "json", _ => throw new ArgumentOutOfRangeException(nameof(format)), }; public static string GetDisplayName(this ExportFormat format) => format switch { ExportFormat.PlainText => "TXT", ExportFormat.HtmlDark => "HTML (Dark)", ExportFormat.HtmlLight => "HTML (Light)", ExportFormat.Csv => "CSV", ExportFormat.Json => "JSON", _ => throw new ArgumentOutOfRangeException(nameof(format)), }; }
```

# Exporting/ExportRequest.cs

```cs
using System; using System.Globalization; using System.IO; using System.Text; using System.Text.RegularExpressions; using DiscordChatExporter.Core.Discord; using DiscordChatExporter.Core.Discord.Data; using DiscordChatExporter.Core.Exporting.Filtering; using DiscordChatExporter.Core.Exporting.Partitioning; using DiscordChatExporter.Core.Utils; using DiscordChatExporter.Core.Utils.Extensions; namespace DiscordChatExporter.Core.Exporting; public partial class ExportRequest { public Guild Guild { get; } public Channel Channel { get; } public string OutputFilePath { get; } public string OutputDirPath { get; } public string AssetsDirPath { get; } public ExportFormat Format { get; } public Snowflake? After { get; } public Snowflake? Before { get; } public PartitionLimit PartitionLimit { get; } public MessageFilter MessageFilter { get; } public bool ShouldFormatMarkdown { get; } public bool ShouldDownloadAssets { get; } public bool ShouldReuseAssets { get; } public string? Locale { get; } public CultureInfo? CultureInfo { get; } public bool IsUtcNormalizationEnabled { get; } public ExportRequest( Guild guild, Channel channel, string outputPath, string? assetsDirPath, ExportFormat format, Snowflake? after, Snowflake? before, PartitionLimit partitionLimit, MessageFilter messageFilter, bool shouldFormatMarkdown, bool shouldDownloadAssets, bool shouldReuseAssets, string? locale, bool isUtcNormalizationEnabled ) { Guild = guild; Channel = channel; Format = format; After = after; Before = before; PartitionLimit = partitionLimit; MessageFilter = messageFilter; ShouldFormatMarkdown = shouldFormatMarkdown; ShouldDownloadAssets = shouldDownloadAssets; ShouldReuseAssets = shouldReuseAssets; Locale = locale; IsUtcNormalizationEnabled = isUtcNormalizationEnabled; OutputFilePath = GetOutputBaseFilePath(Guild, Channel, outputPath, Format, After, Before); OutputDirPath = Path.GetDirectoryName(OutputFilePath)!; AssetsDirPath = !string.IsNullOrWhiteSpace(assetsDirPath) ? FormatPath(assetsDirPath, Guild, Channel, After, Before) : $"{OutputFilePath}_Files{Path.DirectorySeparatorChar}"; CultureInfo = Locale?.Pipe(CultureInfo.GetCultureInfo); } } public partial class ExportRequest { public static string GetDefaultOutputFileName( Guild guild, Channel channel, ExportFormat format, Snowflake? after = null, Snowflake? before = null ) { var buffer = new StringBuilder(); // Guild name buffer.Append(guild.Name); // Parent name if (channel.Parent is not null) buffer.Append(" - ").Append(channel.Parent.Name); // Channel name and ID buffer .Append(" - ") .Append(channel.Name) .Append(' ') .Append('[') .Append(channel.Id) .Append(']'); // Date range if (after is not null || before is not null) { buffer.Append(' ').Append('('); // Both 'after' and 'before' are set if (after is not null && before is not null) { buffer.Append( $"{after.Value.ToDate():yyyy-MM-dd} to {before.Value.ToDate():yyyy-MM-dd}" ); } // Only 'after' is set else if (after is not null) { buffer.Append($"after {after.Value.ToDate():yyyy-MM-dd}"); } // Only 'before' is set else if (before is not null) { buffer.Append($"before {before.Value.ToDate():yyyy-MM-dd}"); } buffer.Append(')'); } // File extension buffer.Append('.').Append(format.GetFileExtension()); return PathEx.EscapeFileName(buffer.ToString()); } private static string FormatPath( string path, Guild guild, Channel channel, Snowflake? after, Snowflake? before ) => Regex.Replace( path, "%.", m => PathEx.EscapeFileName( m.Value switch { "%g" => guild.Id.ToString(), "%G" => guild.Name, "%t" => channel.Parent?.Id.ToString() ?? "", "%T" => channel.Parent?.Name ?? "", "%c" => channel.Id.ToString(), "%C" => channel.Name, "%p" => channel.Position?.ToString(CultureInfo.InvariantCulture) ?? "0", "%P" => channel.Parent?.Position?.ToString(CultureInfo.InvariantCulture) ?? "0", "%a" => after?.ToDate().ToString("yyyy-MM-dd", CultureInfo.InvariantCulture) ?? "", "%b" => before ?.ToDate() .ToString("yyyy-MM-dd", CultureInfo.InvariantCulture) ?? "", "%d" => DateTimeOffset.Now.ToString( "yyyy-MM-dd", CultureInfo.InvariantCulture ), "%%" => "%", _ => m.Value, } ) ); private static string GetOutputBaseFilePath( Guild guild, Channel channel, string outputPath, ExportFormat format, Snowflake? after = null, Snowflake? before = null ) { var actualOutputPath = FormatPath(outputPath, guild, channel, after, before); // Output is a directory if ( Directory.Exists(actualOutputPath) || string.IsNullOrWhiteSpace(Path.GetExtension(actualOutputPath)) ) { var fileName = GetDefaultOutputFileName(guild, channel, format, after, before); return Path.Combine(actualOutputPath, fileName); } // Output is a file return actualOutputPath; } }
```

# Exporting/Filtering/BinaryExpressionKind.cs

```cs
namespace DiscordChatExporter.Core.Exporting.Filtering; internal enum BinaryExpressionKind { Or, And, }
```

# Exporting/Filtering/BinaryExpressionMessageFilter.cs

```cs
using System; using DiscordChatExporter.Core.Discord.Data; namespace DiscordChatExporter.Core.Exporting.Filtering; internal class BinaryExpressionMessageFilter( MessageFilter first, MessageFilter second, BinaryExpressionKind kind ) : MessageFilter { public override bool IsMatch(Message message) => kind switch { BinaryExpressionKind.Or => first.IsMatch(message) || second.IsMatch(message), BinaryExpressionKind.And => first.IsMatch(message) && second.IsMatch(message), _ => throw new InvalidOperationException($"Unknown binary expression kind '{kind}'."), }; }
```

# Exporting/Filtering/ContainsMessageFilter.cs

```cs
using System.Linq; using System.Text.RegularExpressions; using DiscordChatExporter.Core.Discord.Data; namespace DiscordChatExporter.Core.Exporting.Filtering; internal class ContainsMessageFilter(string text) : MessageFilter { // Match content within word boundaries, between spaces, or as the whole input. // For example, "max" shouldn't match on content "our maximum effort", // but should match on content "our max effort". // Also, "(max)" should match on content "our (max) effort", even though // parentheses are not considered word characters. // https://github.com/Tyrrrz/DiscordChatExporter/issues/909 private bool IsMatch(string? content) => !string.IsNullOrWhiteSpace(content) && Regex.IsMatch( content, @"(?:\b|\s|^)" + Regex.Escape(text) + @"(?:\b|\s|$)", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant ); public override bool IsMatch(Message message) => IsMatch(message.Content) || message.Embeds.Any(e => IsMatch(e.Title) || IsMatch(e.Author?.Name) || IsMatch(e.Description) || IsMatch(e.Footer?.Text) || e.Fields.Any(f => IsMatch(f.Name) || IsMatch(f.Value)) ); }
```

# Exporting/Filtering/FromMessageFilter.cs

```cs
using System; using DiscordChatExporter.Core.Discord.Data; namespace DiscordChatExporter.Core.Exporting.Filtering; internal class FromMessageFilter(string value) : MessageFilter { public override bool IsMatch(Message message) => string.Equals(value, message.Author.Name, StringComparison.OrdinalIgnoreCase) || string.Equals(value, message.Author.DisplayName, StringComparison.OrdinalIgnoreCase) || string.Equals(value, message.Author.FullName, StringComparison.OrdinalIgnoreCase) || string.Equals(value, message.Author.Id.ToString(), StringComparison.OrdinalIgnoreCase); }
```

# Exporting/Filtering/HasMessageFilter.cs

```cs
using System; using System.Linq; using DiscordChatExporter.Core.Discord.Data; using DiscordChatExporter.Core.Markdown.Parsing; namespace DiscordChatExporter.Core.Exporting.Filtering; internal class HasMessageFilter(MessageContentMatchKind kind) : MessageFilter { public override bool IsMatch(Message message) => kind switch { MessageContentMatchKind.Link => MarkdownParser.ExtractLinks(message.Content).Any(), MessageContentMatchKind.Embed => message.Embeds.Any(), MessageContentMatchKind.File => message.Attachments.Any(), MessageContentMatchKind.Video => message.Attachments.Any(file => file.IsVideo), MessageContentMatchKind.Image => message.Attachments.Any(file => file.IsImage), MessageContentMatchKind.Sound => message.Attachments.Any(file => file.IsAudio), MessageContentMatchKind.Pin => message.IsPinned, MessageContentMatchKind.Invite => MarkdownParser .ExtractLinks(message.Content) .Select(l => l.Url) .Select(Invite.TryGetCodeFromUrl) .Any(c => !string.IsNullOrWhiteSpace(c)), _ => throw new InvalidOperationException( $"Unknown message content match kind '{kind}'." ), }; }
```

# Exporting/Filtering/MentionsMessageFilter.cs

```cs
using System; using System.Linq; using DiscordChatExporter.Core.Discord.Data; namespace DiscordChatExporter.Core.Exporting.Filtering; internal class MentionsMessageFilter(string value) : MessageFilter { public override bool IsMatch(Message message) => message.MentionedUsers.Any(user => string.Equals(value, user.Name, StringComparison.OrdinalIgnoreCase) || string.Equals(value, user.DisplayName, StringComparison.OrdinalIgnoreCase) || string.Equals(value, user.FullName, StringComparison.OrdinalIgnoreCase) || string.Equals(value, user.Id.ToString(), StringComparison.OrdinalIgnoreCase) ); }
```

# Exporting/Filtering/MessageContentMatchKind.cs

```cs
namespace DiscordChatExporter.Core.Exporting.Filtering; internal enum MessageContentMatchKind { Link, Embed, File, Video, Image, Sound, Pin, Invite, }
```

# Exporting/Filtering/MessageFilter.cs

```cs
using DiscordChatExporter.Core.Discord.Data; using DiscordChatExporter.Core.Exporting.Filtering.Parsing; using Superpower; namespace DiscordChatExporter.Core.Exporting.Filtering; public abstract partial class MessageFilter { public abstract bool IsMatch(Message message); } public partial class MessageFilter { public static MessageFilter Null { get; } = new NullMessageFilter(); public static MessageFilter Parse(string value) => FilterGrammar.Filter.Parse(value); }
```

# Exporting/Filtering/NegatedMessageFilter.cs

```cs
using DiscordChatExporter.Core.Discord.Data; namespace DiscordChatExporter.Core.Exporting.Filtering; internal class NegatedMessageFilter(MessageFilter filter) : MessageFilter { public override bool IsMatch(Message message) => !filter.IsMatch(message); }
```

# Exporting/Filtering/NullMessageFilter.cs

```cs
using DiscordChatExporter.Core.Discord.Data; namespace DiscordChatExporter.Core.Exporting.Filtering; internal class NullMessageFilter : MessageFilter { public override bool IsMatch(Message message) => true; }
```

# Exporting/Filtering/Parsing/FilterGrammar.cs

```cs
using DiscordChatExporter.Core.Utils.Extensions; using Superpower; using Superpower.Parsers; namespace DiscordChatExporter.Core.Exporting.Filtering.Parsing; internal static class FilterGrammar { private static readonly TextParser<char> EscapedCharacter = Character .EqualTo('\\') .IgnoreThen(Character.AnyChar); private static readonly TextParser<string> QuotedString = from open in Character.In('"', '\'') from value in Parse.OneOf(EscapedCharacter, Character.Except(open)).Many().Text() from close in Character.EqualTo(open) select value; private static readonly TextParser<string> UnquotedString = Parse .OneOf( EscapedCharacter, // Avoid whitespace as it's treated as an implicit 'and' operator. // Also avoid all special tokens used by other parsers. Character.ExceptIn(' ', '(', ')', '"', '\'', '-', '~', '|', '&') ) .AtLeastOnce() .Text(); private static readonly TextParser<string> String = Parse .OneOf(QuotedString, UnquotedString) .Named("text string"); private static readonly TextParser<MessageFilter> ContainsFilter = String.Select(v => (MessageFilter)new ContainsMessageFilter(v) ); private static readonly TextParser<MessageFilter> FromFilter = Span.EqualToIgnoreCase("from:") .Try() .IgnoreThen(String) .Select(v => (MessageFilter)new FromMessageFilter(v)) .Named("from:<value>"); private static readonly TextParser<MessageFilter> MentionsFilter = Span.EqualToIgnoreCase( "mentions:" ) .Try() .IgnoreThen(String) .Select(v => (MessageFilter)new MentionsMessageFilter(v)) .Named("mentions:<value>"); private static readonly TextParser<MessageFilter> ReactionFilter = Span.EqualToIgnoreCase( "reaction:" ) .Try() .IgnoreThen(String) .Select(v => (MessageFilter)new ReactionMessageFilter(v)) .Named("reaction:<value>"); private static readonly TextParser<MessageFilter> HasFilter = Span.EqualToIgnoreCase("has:") .Try() .IgnoreThen( Parse.OneOf( Span.EqualToIgnoreCase("link") .IgnoreThen(Parse.Return(MessageContentMatchKind.Link)) .Try(), Span.EqualToIgnoreCase("embed") .IgnoreThen(Parse.Return(MessageContentMatchKind.Embed)) .Try(), Span.EqualToIgnoreCase("file") .IgnoreThen(Parse.Return(MessageContentMatchKind.File)) .Try(), Span.EqualToIgnoreCase("video") .IgnoreThen(Parse.Return(MessageContentMatchKind.Video)) .Try(), Span.EqualToIgnoreCase("image") .IgnoreThen(Parse.Return(MessageContentMatchKind.Image)) .Try(), Span.EqualToIgnoreCase("sound") .IgnoreThen(Parse.Return(MessageContentMatchKind.Sound)), Span.EqualToIgnoreCase("pin") .IgnoreThen(Parse.Return(MessageContentMatchKind.Pin)) .Try(), Span.EqualToIgnoreCase("invite") .IgnoreThen(Parse.Return(MessageContentMatchKind.Invite)) .Try() ) ) .Select(k => (MessageFilter)new HasMessageFilter(k)) .Named("has:<value>"); // Make sure that property-based filters like 'has:link' don't prevent text like 'hello' from being parsed. // https://github.com/Tyrrrz/DiscordChatExporter/issues/909#issuecomment-1227575455 private static readonly TextParser<MessageFilter> PrimitiveFilter = Parse.OneOf( FromFilter, MentionsFilter, ReactionFilter, HasFilter, ContainsFilter ); private static readonly TextParser<MessageFilter> GroupedFilter = from open in Character.EqualTo('(') from content in Parse.Ref(() => ChainedFilter!).Token() from close in Character.EqualTo(')') select content; private static readonly TextParser<MessageFilter> NegatedFilter = Character // Dash is annoying to use from CLI due to conflicts with options, so we provide tilde as an alias .In('-', '~') .IgnoreThen(Parse.OneOf(GroupedFilter, PrimitiveFilter)) .Select(f => (MessageFilter)new NegatedMessageFilter(f)); private static readonly TextParser<MessageFilter> ChainedFilter = Parse.Chain( // Operator Parse.OneOf( // Explicit operator Character.In('|', '&').Token().Try(), // Implicit operator (resolves to 'and') Character.EqualTo(' ').AtLeastOnce().IgnoreThen(Parse.Return(' ')) ), // Operand Parse.OneOf(NegatedFilter, GroupedFilter, PrimitiveFilter), // Reducer (op, left, right) => op switch { '|' => new BinaryExpressionMessageFilter(left, right, BinaryExpressionKind.Or), _ => new BinaryExpressionMessageFilter(left, right, BinaryExpressionKind.And), } ); public static readonly TextParser<MessageFilter> Filter = ChainedFilter.Token().AtEnd(); }
```

# Exporting/Filtering/ReactionMessageFilter.cs

```cs
using System; using System.Linq; using DiscordChatExporter.Core.Discord.Data; namespace DiscordChatExporter.Core.Exporting.Filtering; internal class ReactionMessageFilter(string value) : MessageFilter { public override bool IsMatch(Message message) => message.Reactions.Any(r => string.Equals(value, r.Emoji.Id?.ToString(), StringComparison.OrdinalIgnoreCase) || string.Equals(value, r.Emoji.Name, StringComparison.OrdinalIgnoreCase) || string.Equals(value, r.Emoji.Code, StringComparison.OrdinalIgnoreCase) ); }
```

# Exporting/HtmlMarkdownVisitor.cs

```cs
using System; using System.Linq; using System.Net; using System.Text; using System.Text.RegularExpressions; using System.Threading; using System.Threading.Tasks; using DiscordChatExporter.Core.Discord.Data; using DiscordChatExporter.Core.Markdown; using DiscordChatExporter.Core.Markdown.Parsing; using DiscordChatExporter.Core.Utils.Extensions; namespace DiscordChatExporter.Core.Exporting; internal partial class HtmlMarkdownVisitor( ExportContext context, StringBuilder buffer, bool isJumbo ) : MarkdownVisitor { protected override ValueTask VisitTextAsync( TextNode text, CancellationToken cancellationToken = default ) { buffer.Append(HtmlEncode(text.Text)); return default; } protected override async ValueTask VisitFormattingAsync( FormattingNode formatting, CancellationToken cancellationToken = default ) { var (openingTag, closingTag) = formatting.Kind switch { FormattingKind.Bold => ( // lang=html "<strong>", // lang=html "</strong>" ), FormattingKind.Italic => ( // lang=html "<em>", // lang=html "</em>" ), FormattingKind.Underline => ( // lang=html "<u>", // lang=html "</u>" ), FormattingKind.Strikethrough => ( // lang=html "<s>", // lang=html "</s>" ), FormattingKind.Spoiler => ( // lang=html """<span class="chatlog__markdown-spoiler chatlog__markdown-spoiler--hidden" onclick="showSpoiler(event, this)">""", // lang=html """</span>""" ), FormattingKind.Quote => ( // lang=html """<div class="chatlog__markdown-quote"><div class="chatlog__markdown-quote-border"></div><div class="chatlog__markdown-quote-content">""", // lang=html """</div></div>""" ), _ => throw new InvalidOperationException( $"Unknown formatting kind '{formatting.Kind}'." ), }; buffer.Append(openingTag); await VisitAsync(formatting.Children, cancellationToken); buffer.Append(closingTag); } protected override async ValueTask VisitHeadingAsync( HeadingNode heading, CancellationToken cancellationToken = default ) { buffer.Append( // lang=html $"<h{heading.Level}>" ); await VisitAsync(heading.Children, cancellationToken); buffer.Append( // lang=html $"</h{heading.Level}>" ); } protected override async ValueTask VisitListAsync( ListNode list, CancellationToken cancellationToken = default ) { buffer.Append( // lang=html "<ul>" ); await VisitAsync(list.Items, cancellationToken); buffer.Append( // lang=html "</ul>" ); } protected override async ValueTask VisitListItemAsync( ListItemNode listItem, CancellationToken cancellationToken = default ) { buffer.Append( // lang=html "<li>" ); await VisitAsync(listItem.Children, cancellationToken); buffer.Append( // lang=html "</li>" ); } protected override ValueTask VisitInlineCodeBlockAsync( InlineCodeBlockNode inlineCodeBlock, CancellationToken cancellationToken = default ) { buffer.Append( // lang=html $""" <code class="chatlog__markdown-pre chatlog__markdown-pre--inline">{HtmlEncode( inlineCodeBlock.Code )}</code> """ ); return default; } protected override ValueTask VisitMultiLineCodeBlockAsync( MultiLineCodeBlockNode multiLineCodeBlock, CancellationToken cancellationToken = default ) { var highlightClass = !string.IsNullOrWhiteSpace(multiLineCodeBlock.Language) ? $"language-{multiLineCodeBlock.Language}" : "nohighlight"; buffer.Append( // lang=html $""" <code class="chatlog__markdown-pre chatlog__markdown-pre--multiline {highlightClass}">{HtmlEncode( multiLineCodeBlock.Code )}</code> """ ); return default; } protected override async ValueTask VisitLinkAsync( LinkNode link, CancellationToken cancellationToken = default ) { // Try to extract the message ID if the link points to a Discord message var linkedMessageId = Regex .Match(link.Url, @"^https?://(?:discord|discordapp)\.com/channels/.*?/(\d+)/?$") .Groups[1] .Value; buffer.Append( !string.IsNullOrWhiteSpace(linkedMessageId) // lang=html ? $"""<a href="{HtmlEncode(link.Url)}" onclick="scrollToMessage(event, '{linkedMessageId}')">""" // lang=html : $"""<a href="{HtmlEncode(link.Url)}">""" ); await VisitAsync(link.Children, cancellationToken); buffer.Append( // lang=html "</a>" ); } protected override async ValueTask VisitEmojiAsync( EmojiNode emoji, CancellationToken cancellationToken = default ) { var emojiImageUrl = Emoji.GetImageUrl(emoji.Id, emoji.Name, emoji.IsAnimated); var jumboClass = isJumbo ? "chatlog__emoji--large" : ""; buffer.Append( // lang=html $""" <img loading="lazy" class="chatlog__emoji {jumboClass}" alt="{emoji.Name}" title="{emoji.Code}" src="{await context.ResolveAssetUrlAsync(emojiImageUrl, cancellationToken)}"> """ ); } protected override async ValueTask VisitMentionAsync( MentionNode mention, CancellationToken cancellationToken = default ) { if (mention.Kind == MentionKind.Everyone) { buffer.Append( // lang=html """ <span class="chatlog__markdown-mention">@everyone</span> """ ); } else if (mention.Kind == MentionKind.Here) { buffer.Append( // lang=html """ <span class="chatlog__markdown-mention">@here</span> """ ); } else if (mention.Kind == MentionKind.User) { // User mentions are not always included in the message object, // which means they need to be populated on demand. // https://github.com/Tyrrrz/DiscordChatExporter/issues/304 if (mention.TargetId is not null) await context.PopulateMemberAsync(mention.TargetId.Value, cancellationToken); var member = mention.TargetId?.Pipe(context.TryGetMember); var fullName = member?.User.FullName ?? "Unknown"; var displayName = member?.DisplayName ?? member?.User.DisplayName ?? "Unknown"; buffer.Append( // lang=html $""" <span class="chatlog__markdown-mention" title="{HtmlEncode(fullName)}">@{HtmlEncode( displayName )}</span> """ ); } else if (mention.Kind == MentionKind.Channel) { var channel = mention.TargetId?.Pipe(context.TryGetChannel); var symbol = channel?.IsVoice == true ? "🔊" : "#"; var name = channel?.Name ?? "deleted-channel"; buffer.Append( // lang=html $""" <span class="chatlog__markdown-mention">{symbol}{HtmlEncode(name)}</span> """ ); } else if (mention.Kind == MentionKind.Role) { var role = mention.TargetId?.Pipe(context.TryGetRole); var name = role?.Name ?? "deleted-role"; var color = role?.Color; var style = color is not null ? $""" color: rgb({color.Value.R}, {color.Value.G}, {color .Value .B}); background-color: rgba({color.Value.R}, {color.Value.G}, {color .Value .B}, 0.1); """ : null; buffer.Append( // lang=html $""" <span class="chatlog__markdown-mention" style="{style}">@{HtmlEncode(name)}</span> """ ); } } protected override ValueTask VisitTimestampAsync( TimestampNode timestamp, CancellationToken cancellationToken = default ) { var formatted = timestamp.Instant is not null ? context.FormatDate(timestamp.Instant.Value, timestamp.Format ?? "g") : "Invalid date"; var formattedLong = timestamp.Instant is not null ? context.FormatDate(timestamp.Instant.Value, "f") : ""; buffer.Append( // lang=html $""" <span class="chatlog__markdown-timestamp" title="{HtmlEncode( formattedLong )}">{HtmlEncode(formatted)}</span> """ ); return default; } } internal partial class HtmlMarkdownVisitor { private static string HtmlEncode(string text) => WebUtility.HtmlEncode(text); public static async ValueTask<string> FormatAsync( ExportContext context, string markdown, bool isJumboAllowed = true, CancellationToken cancellationToken = default ) { var nodes = MarkdownParser.Parse(markdown); var isJumbo = isJumboAllowed && nodes.All(n => n is EmojiNode || n is TextNode textNode && string.IsNullOrWhiteSpace(textNode.Text) ); var buffer = new StringBuilder(); await new HtmlMarkdownVisitor(context, buffer, isJumbo).VisitAsync( nodes, cancellationToken ); return buffer.ToString(); } }
```

# Exporting/HtmlMessageExtensions.cs

```cs
using System; using DiscordChatExporter.Core.Discord.Data; using DiscordChatExporter.Core.Discord.Data.Embeds; namespace DiscordChatExporter.Core.Exporting; internal static class HtmlMessageExtensions { // Message content is hidden if it's a link to an embedded media // https://github.com/Tyrrrz/DiscordChatExporter/issues/682 public static bool IsContentHidden(this Message message) { if (message.Embeds.Count != 1) return false; var embed = message.Embeds[0]; return string.Equals(message.Content.Trim(), embed.Url, StringComparison.OrdinalIgnoreCase) && embed.Kind is EmbedKind.Image or EmbedKind.Gifv; } }
```

# Exporting/HtmlMessageWriter.cs

```cs
using System; using System.Collections.Generic; using System.IO; using System.Linq; using System.Threading; using System.Threading.Tasks; using DiscordChatExporter.Core.Discord.Data; using WebMarkupMin.Core; namespace DiscordChatExporter.Core.Exporting; internal class HtmlMessageWriter(Stream stream, ExportContext context, string themeName) : MessageWriter(stream, context) { private readonly TextWriter _writer = new StreamWriter(stream); private readonly HtmlMinifier _minifier = new(); private readonly List<Message> _messageGroup = []; private bool CanJoinGroup(Message message) { // If the group is empty, any message can join it if (_messageGroup.LastOrDefault() is not { } lastMessage) return true; // Reply-like messages cannot join existing groups because they need to appear first if (message.IsReplyLike) return false; // Grouping for system notifications if (message.IsSystemNotification) { // Can only be grouped with other system notifications if (!lastMessage.IsSystemNotification) return false; } // Grouping for normal messages else { // Can only be grouped with other normal messages if (lastMessage.IsSystemNotification) return false; // Messages must be within 7 minutes of each other if ((message.Timestamp - lastMessage.Timestamp).Duration().TotalMinutes > 7) return false; // Messages must be sent by the same author if (message.Author.Id != lastMessage.Author.Id) return false; // If the author changed their name after the last message, their new messages // cannot join the existing group. if ( !string.Equals( message.Author.FullName, lastMessage.Author.FullName, StringComparison.Ordinal ) ) return false; } return true; } // Use <!--wmm:ignore--> to preserve blocks of code inside the templates private string Minify(string html) => _minifier.Minify(html, false).MinifiedContent; public override async ValueTask WritePreambleAsync( CancellationToken cancellationToken = default ) { await _writer.WriteLineAsync( Minify( await new PreambleTemplate { Context = Context, ThemeName = themeName }.RenderAsync( cancellationToken ) ) ); } private async ValueTask WriteMessageGroupAsync( IReadOnlyList<Message> messages, CancellationToken cancellationToken = default ) { await _writer.WriteLineAsync( Minify( await new MessageGroupTemplate { Context = Context, Messages = messages, }.RenderAsync(cancellationToken) ) ); } public override async ValueTask WriteMessageAsync( Message message, CancellationToken cancellationToken = default ) { await base.WriteMessageAsync(message, cancellationToken); // If the message can be grouped, buffer it for now if (CanJoinGroup(message)) { _messageGroup.Add(message); } // Otherwise, flush the group and render messages else { await WriteMessageGroupAsync(_messageGroup, cancellationToken); _messageGroup.Clear(); _messageGroup.Add(message); } } public override async ValueTask WritePostambleAsync( CancellationToken cancellationToken = default ) { // Flush current message group if (_messageGroup.Any()) await WriteMessageGroupAsync(_messageGroup, cancellationToken); await _writer.WriteLineAsync( Minify( await new PostambleTemplate { Context = Context, MessagesWritten = MessagesWritten, }.RenderAsync(cancellationToken) ) ); } public override async ValueTask DisposeAsync() { await _writer.DisposeAsync(); await base.DisposeAsync(); } }
```

# Exporting/JsonMessageWriter.cs

```cs
using System; using System.Collections.Generic; using System.IO; using System.Text.Encodings.Web; using System.Text.Json; using System.Threading; using System.Threading.Tasks; using DiscordChatExporter.Core.Discord.Data; using DiscordChatExporter.Core.Discord.Data.Embeds; using DiscordChatExporter.Core.Utils.Extensions; using JsonExtensions.Writing; namespace DiscordChatExporter.Core.Exporting; internal class JsonMessageWriter(Stream stream, ExportContext context) : MessageWriter(stream, context) { private readonly Utf8JsonWriter _writer = new( stream, new JsonWriterOptions { // https://github.com/Tyrrrz/DiscordChatExporter/issues/450 Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping, Indented = true, // Validation errors may mask actual failures // https://github.com/Tyrrrz/DiscordChatExporter/issues/413 SkipValidation = true, } ); private async ValueTask<string> FormatMarkdownAsync( string markdown, CancellationToken cancellationToken = default ) => Context.Request.ShouldFormatMarkdown ? await PlainTextMarkdownVisitor.FormatAsync(Context, markdown, cancellationToken) : markdown; private async ValueTask WriteUserAsync(User user, CancellationToken cancellationToken = default) { _writer.WriteStartObject(); _writer.WriteString("id", user.Id.ToString()); _writer.WriteString("name", user.Name); _writer.WriteString("discriminator", user.DiscriminatorFormatted); _writer.WriteString( "nickname", Context.TryGetMember(user.Id)?.DisplayName ?? user.DisplayName ); _writer.WriteString("color", Context.TryGetUserColor(user.Id)?.ToHex()); _writer.WriteBoolean("isBot", user.IsBot); _writer.WritePropertyName("roles"); await WriteRolesAsync(Context.GetUserRoles(user.Id), cancellationToken); _writer.WriteString( "avatarUrl", await Context.ResolveAssetUrlAsync( Context.TryGetMember(user.Id)?.AvatarUrl ?? user.AvatarUrl, cancellationToken ) ); _writer.WriteEndObject(); await _writer.FlushAsync(cancellationToken); } private async ValueTask WriteRolesAsync( IReadOnlyList<Role> roles, CancellationToken cancellationToken = default ) { _writer.WriteStartArray(); foreach (var role in roles) { _writer.WriteStartObject(); _writer.WriteString("id", role.Id.ToString()); _writer.WriteString("name", role.Name); _writer.WriteString("color", role.Color?.ToHex()); _writer.WriteNumber("position", role.Position); _writer.WriteEndObject(); } _writer.WriteEndArray(); await _writer.FlushAsync(cancellationToken); } private async ValueTask WriteEmbedAuthorAsync( EmbedAuthor embedAuthor, CancellationToken cancellationToken = default ) { _writer.WriteStartObject(); _writer.WriteString("name", embedAuthor.Name); _writer.WriteString("url", embedAuthor.Url); if (!string.IsNullOrWhiteSpace(embedAuthor.IconUrl)) { _writer.WriteString( "iconUrl", await Context.ResolveAssetUrlAsync( embedAuthor.IconProxyUrl ?? embedAuthor.IconUrl, cancellationToken ) ); } _writer.WriteEndObject(); await _writer.FlushAsync(cancellationToken); } private async ValueTask WriteEmbedImageAsync( EmbedImage embedImage, CancellationToken cancellationToken = default ) { _writer.WriteStartObject(); if (!string.IsNullOrWhiteSpace(embedImage.Url)) { _writer.WriteString( "url", await Context.ResolveAssetUrlAsync( embedImage.ProxyUrl ?? embedImage.Url, cancellationToken ) ); } _writer.WriteNumber("width", embedImage.Width); _writer.WriteNumber("height", embedImage.Height); _writer.WriteEndObject(); await _writer.FlushAsync(cancellationToken); } private async ValueTask WriteEmbedVideoAsync( EmbedVideo embedVideo, CancellationToken cancellationToken = default ) { _writer.WriteStartObject(); if (!string.IsNullOrWhiteSpace(embedVideo.Url)) { _writer.WriteString( "url", await Context.ResolveAssetUrlAsync( embedVideo.ProxyUrl ?? embedVideo.Url, cancellationToken ) ); } _writer.WriteNumber("width", embedVideo.Width); _writer.WriteNumber("height", embedVideo.Height); _writer.WriteEndObject(); await _writer.FlushAsync(cancellationToken); } private async ValueTask WriteEmbedFooterAsync( EmbedFooter embedFooter, CancellationToken cancellationToken = default ) { _writer.WriteStartObject(); _writer.WriteString("text", embedFooter.Text); if (!string.IsNullOrWhiteSpace(embedFooter.IconUrl)) { _writer.WriteString( "iconUrl", await Context.ResolveAssetUrlAsync( embedFooter.IconProxyUrl ?? embedFooter.IconUrl, cancellationToken ) ); } _writer.WriteEndObject(); await _writer.FlushAsync(cancellationToken); } private async ValueTask WriteEmbedFieldAsync( EmbedField embedField, CancellationToken cancellationToken = default ) { _writer.WriteStartObject(); _writer.WriteString("name", await FormatMarkdownAsync(embedField.Name, cancellationToken)); _writer.WriteString( "value", await FormatMarkdownAsync(embedField.Value, cancellationToken) ); _writer.WriteBoolean("isInline", embedField.IsInline); _writer.WriteEndObject(); await _writer.FlushAsync(cancellationToken); } private async ValueTask WriteEmbedAsync( Embed embed, CancellationToken cancellationToken = default ) { _writer.WriteStartObject(); _writer.WriteString( "title", await FormatMarkdownAsync(embed.Title ?? "", cancellationToken) ); _writer.WriteString("url", embed.Url); _writer.WriteString("timestamp", embed.Timestamp?.Pipe(Context.NormalizeDate)); _writer.WriteString( "description", await FormatMarkdownAsync(embed.Description ?? "", cancellationToken) ); if (embed.Color is not null) _writer.WriteString("color", embed.Color.Value.ToHex()); if (embed.Author is not null) { _writer.WritePropertyName("author"); await WriteEmbedAuthorAsync(embed.Author, cancellationToken); } if (embed.Thumbnail is not null) { _writer.WritePropertyName("thumbnail"); await WriteEmbedImageAsync(embed.Thumbnail, cancellationToken); } if (embed.Image is not null) { _writer.WritePropertyName("image"); await WriteEmbedImageAsync(embed.Image, cancellationToken); } if (embed.Video is not null) { _writer.WritePropertyName("video"); await WriteEmbedVideoAsync(embed.Video, cancellationToken); } if (embed.Footer is not null) { _writer.WritePropertyName("footer"); await WriteEmbedFooterAsync(embed.Footer, cancellationToken); } // Images _writer.WriteStartArray("images"); foreach (var image in embed.Images) await WriteEmbedImageAsync(image, cancellationToken); _writer.WriteEndArray(); // Fields _writer.WriteStartArray("fields"); foreach (var field in embed.Fields) await WriteEmbedFieldAsync(field, cancellationToken); _writer.WriteEndArray(); _writer.WriteEndObject(); await _writer.FlushAsync(cancellationToken); } public override async ValueTask WritePreambleAsync( CancellationToken cancellationToken = default ) { // Root object (start) _writer.WriteStartObject(); // Guild _writer.WriteStartObject("guild"); _writer.WriteString("id", Context.Request.Guild.Id.ToString()); _writer.WriteString("name", Context.Request.Guild.Name); _writer.WriteString( "iconUrl", await Context.ResolveAssetUrlAsync(Context.Request.Guild.IconUrl, cancellationToken) ); _writer.WriteEndObject(); // Channel _writer.WriteStartObject("channel"); _writer.WriteString("id", Context.Request.Channel.Id.ToString()); _writer.WriteString("type", Context.Request.Channel.Kind.ToString()); // Original schema did not account for threads, so 'category' actually refers to the parent channel _writer.WriteString("categoryId", Context.Request.Channel.Parent?.Id.ToString()); _writer.WriteString("category", Context.Request.Channel.Parent?.Name); _writer.WriteString("name", Context.Request.Channel.Name); _writer.WriteString("topic", Context.Request.Channel.Topic); if (!string.IsNullOrWhiteSpace(Context.Request.Channel.IconUrl)) { _writer.WriteString( "iconUrl", await Context.ResolveAssetUrlAsync( Context.Request.Channel.IconUrl, cancellationToken ) ); } _writer.WriteEndObject(); // Date range _writer.WriteStartObject("dateRange"); _writer.WriteString("after", Context.Request.After?.ToDate().Pipe(Context.NormalizeDate)); _writer.WriteString("before", Context.Request.Before?.ToDate().Pipe(Context.NormalizeDate)); _writer.WriteEndObject(); // Timestamp _writer.WriteString("exportedAt", Context.NormalizeDate(DateTimeOffset.UtcNow)); // Message array (start) _writer.WriteStartArray("messages"); await _writer.FlushAsync(cancellationToken); } public override async ValueTask WriteMessageAsync( Message message, CancellationToken cancellationToken = default ) { await base.WriteMessageAsync(message, cancellationToken); _writer.WriteStartObject(); // Metadata _writer.WriteString("id", message.Id.ToString()); _writer.WriteString("type", message.Kind.ToString()); _writer.WriteString("timestamp", Context.NormalizeDate(message.Timestamp)); _writer.WriteString( "timestampEdited", message.EditedTimestamp?.Pipe(Context.NormalizeDate) ); _writer.WriteString( "callEndedTimestamp", message.CallEndedTimestamp?.Pipe(Context.NormalizeDate) ); _writer.WriteBoolean("isPinned", message.IsPinned); // Content if (message.IsSystemNotification) { _writer.WriteString("content", message.GetFallbackContent()); } else { _writer.WriteString( "content", await FormatMarkdownAsync(message.Content, cancellationToken) ); } // Author _writer.WritePropertyName("author"); await WriteUserAsync(message.Author, cancellationToken); // Attachments _writer.WriteStartArray("attachments"); foreach (var attachment in message.Attachments) { _writer.WriteStartObject(); _writer.WriteString("id", attachment.Id.ToString()); _writer.WriteString( "url", await Context.ResolveAssetUrlAsync(attachment.Url, cancellationToken) ); _writer.WriteString("fileName", attachment.FileName); _writer.WriteNumber("fileSizeBytes", attachment.FileSize.TotalBytes); _writer.WriteEndObject(); } _writer.WriteEndArray(); // Embeds _writer.WriteStartArray("embeds"); foreach (var embed in message.Embeds) await WriteEmbedAsync(embed, cancellationToken); _writer.WriteEndArray(); // Stickers _writer.WriteStartArray("stickers"); foreach (var sticker in message.Stickers) { _writer.WriteStartObject(); _writer.WriteString("id", sticker.Id.ToString()); _writer.WriteString("name", sticker.Name); _writer.WriteString("format", sticker.Format.ToString()); _writer.WriteString( "sourceUrl", await Context.ResolveAssetUrlAsync(sticker.SourceUrl, cancellationToken) ); _writer.WriteEndObject(); } _writer.WriteEndArray(); // Reactions _writer.WriteStartArray("reactions"); foreach (var reaction in message.Reactions) { _writer.WriteStartObject(); // Emoji _writer.WriteStartObject("emoji"); _writer.WriteString("id", reaction.Emoji.Id.ToString()); _writer.WriteString("name", reaction.Emoji.Name); _writer.WriteString("code", reaction.Emoji.Code); _writer.WriteBoolean("isAnimated", reaction.Emoji.IsAnimated); _writer.WriteString( "imageUrl", await Context.ResolveAssetUrlAsync(reaction.Emoji.ImageUrl, cancellationToken) ); _writer.WriteEndObject(); _writer.WriteNumber("count", reaction.Count); _writer.WriteStartArray("users"); await foreach ( var user in Context.Discord.GetMessageReactionsAsync( Context.Request.Channel.Id, message.Id, reaction.Emoji, cancellationToken ) ) { _writer.WriteStartObject(); // Write limited user information without color and roles, // so we can avoid fetching guild member information for each user. _writer.WriteString("id", user.Id.ToString()); _writer.WriteString("name", user.Name); _writer.WriteString("discriminator", user.DiscriminatorFormatted); _writer.WriteString( "nickname", Context.TryGetMember(user.Id)?.DisplayName ?? user.DisplayName ); _writer.WriteBoolean("isBot", user.IsBot); _writer.WriteString( "avatarUrl", await Context.ResolveAssetUrlAsync( Context.TryGetMember(user.Id)?.AvatarUrl ?? user.AvatarUrl, cancellationToken ) ); _writer.WriteEndObject(); } _writer.WriteEndArray(); _writer.WriteEndObject(); } _writer.WriteEndArray(); // Mentions _writer.WriteStartArray("mentions"); foreach (var user in message.MentionedUsers) await WriteUserAsync(user, cancellationToken); _writer.WriteEndArray(); // Message reference if (message.Reference is not null) { _writer.WriteStartObject("reference"); _writer.WriteString("messageId", message.Reference.MessageId?.ToString()); _writer.WriteString("channelId", message.Reference.ChannelId?.ToString()); _writer.WriteString("guildId", message.Reference.GuildId?.ToString()); _writer.WriteEndObject(); } // Interaction if (message.Interaction is not null) { _writer.WriteStartObject("interaction"); _writer.WriteString("id", message.Interaction.Id.ToString()); _writer.WriteString("name", message.Interaction.Name); _writer.WritePropertyName("user"); await WriteUserAsync(message.Interaction.User, cancellationToken); _writer.WriteEndObject(); } _writer.WriteEndObject(); await _writer.FlushAsync(cancellationToken); } public override async ValueTask WritePostambleAsync( CancellationToken cancellationToken = default ) { // Message array (end) _writer.WriteEndArray(); _writer.WriteNumber("messageCount", MessagesWritten); // Root object (end) _writer.WriteEndObject(); await _writer.FlushAsync(cancellationToken); } public override async ValueTask DisposeAsync() { await _writer.DisposeAsync(); await base.DisposeAsync(); } }
```

# Exporting/MessageExporter.cs

```cs
using System; using System.IO; using System.Threading; using System.Threading.Tasks; using DiscordChatExporter.Core.Discord.Data; namespace DiscordChatExporter.Core.Exporting; internal partial class MessageExporter(ExportContext context) : IAsyncDisposable { private int _partitionIndex; private MessageWriter? _writer; public long MessagesExported { get; private set; } private async ValueTask ResetWriterAsync(CancellationToken cancellationToken = default) { if (_writer is not null) { try { await _writer.WritePostambleAsync(cancellationToken); } // Writer must be disposed, even if it fails to write the postamble finally { await _writer.DisposeAsync(); _writer = null; } } } private async ValueTask<MessageWriter> GetWriterAsync( CancellationToken cancellationToken = default ) { // Ensure that the partition limit has not been reached if ( _writer is not null && context.Request.PartitionLimit.IsReached( _writer.MessagesWritten, _writer.BytesWritten ) ) { await ResetWriterAsync(cancellationToken); _partitionIndex++; } // Writer is still valid, return if (_writer is not null) return _writer; Directory.CreateDirectory(context.Request.OutputDirPath); var filePath = GetPartitionFilePath(context.Request.OutputFilePath, _partitionIndex); var writer = CreateMessageWriter(filePath, context.Request.Format, context); await writer.WritePreambleAsync(cancellationToken); return _writer = writer; } public async ValueTask ExportMessageAsync( Message message, CancellationToken cancellationToken = default ) { var writer = await GetWriterAsync(cancellationToken); await writer.WriteMessageAsync(message, cancellationToken); MessagesExported++; } public async ValueTask DisposeAsync() => await ResetWriterAsync(); } internal partial class MessageExporter { private static string GetPartitionFilePath(string baseFilePath, int partitionIndex) { // First partition, don't change the file name if (partitionIndex <= 0) return baseFilePath; // Inject partition index into the file name var fileNameWithoutExt = Path.GetFileNameWithoutExtension(baseFilePath); var fileExt = Path.GetExtension(baseFilePath); var fileName = $"{fileNameWithoutExt} [part {partitionIndex + 1}]{fileExt}"; var dirPath = Path.GetDirectoryName(baseFilePath); return !string.IsNullOrWhiteSpace(dirPath) ? Path.Combine(dirPath, fileName) : fileName; } private static MessageWriter CreateMessageWriter( string filePath, ExportFormat format, ExportContext context ) => format switch { ExportFormat.PlainText => new PlainTextMessageWriter(File.Create(filePath), context), ExportFormat.Csv => new CsvMessageWriter(File.Create(filePath), context), ExportFormat.HtmlDark => new HtmlMessageWriter(File.Create(filePath), context, "Dark"), ExportFormat.HtmlLight => new HtmlMessageWriter( File.Create(filePath), context, "Light" ), ExportFormat.Json => new JsonMessageWriter(File.Create(filePath), context), _ => throw new ArgumentOutOfRangeException( nameof(format), $"Unknown export format '{format}'." ), }; }
```

# Exporting/MessageGroupTemplate.cshtml

```cshtml
@using System @using System.Collections.Generic @using System.Linq @using System.Threading.Tasks @using DiscordChatExporter.Core.Discord.Data @using DiscordChatExporter.Core.Discord.Data.Embeds @using DiscordChatExporter.Core.Markdown.Parsing @using DiscordChatExporter.Core.Utils.Extensions @inherits RazorBlade.HtmlTemplate @functions { public required ExportContext Context { get; init; } public required IReadOnlyList<Message> Messages { get; init; } } @{ ValueTask<string> ResolveAssetUrlAsync(string url) => Context.ResolveAssetUrlAsync(url, CancellationToken); string FormatDate(DateTimeOffset instant, string format = "g") => Context.FormatDate(instant, format); async ValueTask<string> FormatMarkdownAsync(string markdown) => Context.Request.ShouldFormatMarkdown ? await HtmlMarkdownVisitor.FormatAsync(Context, markdown, true, CancellationToken) : markdown; async ValueTask<string> FormatEmbedMarkdownAsync(string markdown) => Context.Request.ShouldFormatMarkdown ? await HtmlMarkdownVisitor.FormatAsync(Context, markdown, false, CancellationToken) : markdown; } <div class="chatlog__message-group"> @foreach (var (message, i) in Messages.WithIndex()) { var isFirst = i == 0; var authorMember = Context.TryGetMember(message.Author.Id); var authorColor = Context.TryGetUserColor(message.Author.Id); var authorDisplayName = message.Author.IsBot ? message.Author.DisplayName : authorMember?.DisplayName ?? message.Author.DisplayName; <div id="chatlog__message-container-@message.Id" class="chatlog__message-container @(message.IsPinned ? "chatlog__message-container--pinned" : null)" data-message-id="@message.Id"> <div class="chatlog__message"> @* System notification *@ @if (message.IsSystemNotification) { <div class="chatlog__message-aside"> <svg class="chatlog__system-notification-icon"> @{ var icon = message.Kind switch { MessageKind.RecipientAdd => "join-icon", MessageKind.RecipientRemove => "leave-icon", MessageKind.Call => "call-icon", MessageKind.ChannelNameChange => "pencil-icon", MessageKind.ChannelIconChange => "pencil-icon", MessageKind.ChannelPinnedMessage => "pin-icon", MessageKind.GuildMemberJoin => "join-icon", MessageKind.ThreadCreated => "thread-icon", _ => "pencil-icon" }; } <use href="#@icon"></use> </svg> </div> <div class="chatlog__message-primary"> @* Author name *@ <span class="chatlog__system-notification-author" style="@(authorColor is not null ? $"color: rgb({authorColor.Value.R}, {authorColor.Value.G}, {authorColor.Value.B})" : null)" title="@message.Author.FullName" data-user-id="@message.Author.Id">@authorDisplayName</span> @* Space out the content *@ <span> </span> @* System notification content *@ <span class="chatlog__system-notification-content"> @if (message.Kind == MessageKind.RecipientAdd && message.MentionedUsers.Any()) { <span>added </span> <a class="chatlog__system-notification-link" title="@message.MentionedUsers.First().FullName">@message.MentionedUsers.First().DisplayName</a> <span> to the group.</span> } else if (message.Kind == MessageKind.RecipientRemove && message.MentionedUsers.Any()) { if (message.Author.Id == message.MentionedUsers.First().Id) { <span>left the group.</span> } else { <span>removed </span> <a class="chatlog__system-notification-link" title="@message.MentionedUsers.First().FullName">@message.MentionedUsers.First().DisplayName</a> <span> from the group.</span> } } else if (message.Kind == MessageKind.Call) { <span>started a call that lasted @(((message.CallEndedTimestamp ?? message.Timestamp) - message.Timestamp).TotalMinutes.ToString("n0", Context.Request.CultureInfo)) minutes</span> } else if (message.Kind == MessageKind.ChannelNameChange) { <span>changed the channel name: </span> <span class="chatlog__system-notification-link">@message.Content</span> } else if (message.Kind == MessageKind.ChannelIconChange) { <span>changed the channel icon.</span> } else if (message.Kind == MessageKind.ChannelPinnedMessage && message.Reference is not null) { <span>pinned </span> <a class="chatlog__system-notification-link" href="#chatlog__message-container-@message.Reference.MessageId">a message</a> <span> to this channel.</span> } else if (message.Kind == MessageKind.ThreadCreated) { <span>started a thread.</span> } else if (message.Kind == MessageKind.GuildMemberJoin) { <span>joined the server.</span> } else { <span>@message.Content.ToLowerInvariant()</span> } </span> @* Timestamp *@ <span class="chatlog__system-notification-timestamp" title="@FormatDate(message.Timestamp, "f")"> <a href="#chatlog__message-container-@message.Id">@FormatDate(message.Timestamp)</a> </span> </div> } // Regular message else { <div class="chatlog__message-aside"> @if (isFirst) { // Reply symbol if (message.IsReplyLike) { <div class="chatlog__reply-symbol"></div> } // Avatar <img class="chatlog__avatar" src="@await ResolveAssetUrlAsync(authorMember?.AvatarUrl ?? message.Author.AvatarUrl)" alt="Avatar" loading="lazy"> } else { <div class="chatlog__short-timestamp" title="@FormatDate(message.Timestamp, "f")">@FormatDate(message.Timestamp, "t")</div> } </div> <div class="chatlog__message-primary"> @if (isFirst) { // Message referenced by the reply if (message.IsReplyLike) { <div class="chatlog__reply"> @if (message.ReferencedMessage is not null) { var referencedUserMember = Context.TryGetMember(message.ReferencedMessage.Author.Id); var referencedUserColor = Context.TryGetUserColor(message.ReferencedMessage.Author.Id); var referencedUserDisplayName = message.ReferencedMessage.Author.IsBot ? message.ReferencedMessage.Author.DisplayName : referencedUserMember?.DisplayName ?? message.ReferencedMessage.Author.DisplayName; <img class="chatlog__reply-avatar" src="@await ResolveAssetUrlAsync(referencedUserMember?.AvatarUrl ?? message.ReferencedMessage.Author.AvatarUrl)" alt="Avatar" loading="lazy"> <div class="chatlog__reply-author" style="@(referencedUserColor is not null ? $"color: rgb({referencedUserColor.Value.R}, {referencedUserColor.Value.G}, {referencedUserColor.Value.B})" : null)" title="@message.ReferencedMessage.Author.FullName">@referencedUserDisplayName</div> <div class="chatlog__reply-content"> <span class="chatlog__reply-link" onclick="scrollToMessage(event, '@message.ReferencedMessage.Id')"> @if (!string.IsNullOrWhiteSpace(message.ReferencedMessage.Content) && !message.ReferencedMessage.IsContentHidden()) { <!--wmm:ignore-->@Html.Raw(await FormatEmbedMarkdownAsync(message.ReferencedMessage.Content))<!--/wmm:ignore--> } else if (message.ReferencedMessage.Attachments.Any() || message.ReferencedMessage.Embeds.Any()) { <em>Click to see attachment</em> <span>🖼️</span> } else { <em>Click to see original message</em> } </span> @if (message.ReferencedMessage.EditedTimestamp is not null) { <span class="chatlog__reply-edited-timestamp" title="@FormatDate(message.ReferencedMessage.EditedTimestamp.Value, "f")">(edited)</span> } </div> } else if (message.Interaction is not null) { var interactionUserMember = Context.TryGetMember(message.Interaction.User.Id); var interactionUserColor = Context.TryGetUserColor(message.Interaction.User.Id); var interactionUserDisplayName = message.Interaction.User.IsBot ? message.Interaction.User.DisplayName : interactionUserMember?.DisplayName ?? message.Interaction.User.DisplayName; <img class="chatlog__reply-avatar" src="@await ResolveAssetUrlAsync(interactionUserMember?.AvatarUrl ?? message.Interaction.User.AvatarUrl)" alt="Avatar" loading="lazy"> <div class="chatlog__reply-author" style="@(interactionUserColor is not null ? $"color: rgb({interactionUserColor.Value.R}, {interactionUserColor.Value.G}, {interactionUserColor.Value.B})" : null)" title="@message.Interaction.User.FullName">@interactionUserDisplayName</div> <div class="chatlog__reply-content"> used /@message.Interaction.Name </div> } else { <div class="chatlog__reply-unknown"> Original message was deleted or could not be loaded. </div> } </div> } // Header <div class="chatlog__header"> @* Author name *@ <span class="chatlog__author" style="@(authorColor is not null ? $"color: rgb({authorColor.Value.R}, {authorColor.Value.G}, {authorColor.Value.B})" : null)" title="@message.Author.FullName" data-user-id="@message.Author.Id">@authorDisplayName</span> @* Bot tag *@ @if (message.Author.IsBot) { // For cross-posts, the BOT tag is replaced with the SERVER tag if (message.Flags.HasFlag(MessageFlags.CrossPost)) { <span class="chatlog__author-tag">SERVER</span> } else { <span class="chatlog__author-tag">BOT</span> } } @* Timestamp *@ <span class="chatlog__timestamp" title="@FormatDate(message.Timestamp, "f")"><a href="#chatlog__message-container-@message.Id">@FormatDate(message.Timestamp)</a></span> </div> } @* Content *@ @if ((!string.IsNullOrWhiteSpace(message.Content) && !message.IsContentHidden()) || message.EditedTimestamp is not null) { <div class="chatlog__content chatlog__markdown"> @* Text *@ @if (!string.IsNullOrWhiteSpace(message.Content) && !message.IsContentHidden()) { <span class="chatlog__markdown-preserve"><!--wmm:ignore-->@Html.Raw(await FormatMarkdownAsync(message.Content))<!--/wmm:ignore--></span> } @* Edited timestamp *@ @if (message.EditedTimestamp is not null) { <span class="chatlog__edited-timestamp" title="@FormatDate(message.EditedTimestamp.Value, "f")">(edited)</span> } </div> } @* Attachments *@ @foreach (var attachment in message.Attachments) { <div class="chatlog__attachment @(attachment.IsSpoiler ? "chatlog__attachment--hidden" : null)" onclick="@(attachment.IsSpoiler ? "showSpoiler(event, this)" : null)"> @* Spoiler caption *@ @if (attachment.IsSpoiler) { <div class="chatlog__attachment-spoiler-caption">SPOILER</div> } @* Attachment preview *@ @if (attachment.IsImage) { <a href="@await ResolveAssetUrlAsync(attachment.Url)"> <img class="chatlog__attachment-media" src="@await ResolveAssetUrlAsync(attachment.Url)" alt="@(attachment.Description ?? "Image attachment")" title="Image: @attachment.FileName (@attachment.FileSize)" loading="lazy"> </a> } else if (attachment.IsVideo) { <video class="chatlog__attachment-media" controls> <source src="@await ResolveAssetUrlAsync(attachment.Url)" alt="@(attachment.Description ?? "Video attachment")" title="Video: @attachment.FileName (@attachment.FileSize)"> </video> } else if (attachment.IsAudio) { <audio class="chatlog__attachment-media" controls> <source src="@await ResolveAssetUrlAsync(attachment.Url)" alt="@(attachment.Description ?? "Audio attachment")" title="Audio: @attachment.FileName (@attachment.FileSize)"> </audio> } else { <div class="chatlog__attachment-generic"> <svg class="chatlog__attachment-generic-icon"> <use href="#attachment-icon"/> </svg> <div class="chatlog__attachment-generic-name"> <a href="@await ResolveAssetUrlAsync(attachment.Url)"> @attachment.FileName </a> </div> <div class="chatlog__attachment-generic-size"> @attachment.FileSize </div> </div> } </div> } @* Invites *@ @{ var inviteCodes = MarkdownParser .ExtractLinks(message.Content) .Select(l => l.Url) .Select(Invite.TryGetCodeFromUrl) .WhereNotNull() .ToArray(); foreach (var inviteCode in inviteCodes) { var invite = await Context.Discord.TryGetInviteAsync(inviteCode, CancellationToken); if (invite is null) { continue; } <div class="chatlog__embed"> <div class="chatlog__embed-invite-container"> <div class="chatlog__embed-invite-title">@(invite.Channel?.IsDirect == true ? "Invite to join a group DM" : "Invite to join a server")</div> <div class="chatlog__embed-invite"> <div class="chatlog__embed-invite-guild-icon-container"> <img class="chatlog__embed-invite-guild-icon" src="@await ResolveAssetUrlAsync(invite.Channel?.IconUrl ?? invite.Guild.IconUrl)" alt="Guild icon" loading="lazy"> </div> <div class="chatlog__embed-invite-info"> <div class="chatlog__embed-invite-guild-name"> <a href="https://discord.gg/@invite.Code"> @(invite.Guild.Name) </a> </div> <div class="chatlog__embed-invite-channel-name"> <svg class="chatlog__embed-invite-channel-icon"> <use href="#channel-icon"></use> </svg> <span> @(invite.Channel?.Name ?? "Unknown Channel")</span> </div> </div> </div> </div> </div> } } @* Embeds *@ @foreach (var embed in message.Embeds) { // Spotify embed if (embed.TryGetSpotifyTrack() is { } spotifyTrackEmbed) { <div class="chatlog__embed"> <div class="chatlog__embed-spotify-container"> <iframe class="chatlog__embed-spotify" src="@spotifyTrackEmbed.Url" width="400" height="80" allowtransparency="true" allow="encrypted-media"></iframe> </div> </div> } // YouTube embed else if (embed.TryGetYouTubeVideo() is { } youTubeVideoEmbed) { <div class="chatlog__embed"> @* Color pill *@ @if (embed.Color is not null) { <div class="chatlog__embed-color-pill" style="background-color: rgba(@embed.Color.Value.R, @embed.Color.Value.G, @embed.Color.Value.B, @embed.Color.Value.A)"></div> } else { <div class="chatlog__embed-color-pill chatlog__embed-color-pill--default"></div> } <div class="chatlog__embed-content-container"> <div class="chatlog__embed-content"> <div class="chatlog__embed-text"> @* Embed author *@ @if (embed.Author is not null) { <div class="chatlog__embed-author-container"> @if (!string.IsNullOrWhiteSpace(embed.Author.IconUrl)) { <img class="chatlog__embed-author-icon" src="@await ResolveAssetUrlAsync(embed.Author.IconProxyUrl ?? embed.Author.IconUrl)" alt="Author icon" loading="lazy" onerror="this.style.visibility='hidden'"> } @if (!string.IsNullOrWhiteSpace(embed.Author.Name)) { if (!string.IsNullOrWhiteSpace(embed.Author.Url)) { <a class="chatlog__embed-author-link" href="@embed.Author.Url"> <div class="chatlog__embed-author">@embed.Author.Name</div> </a> } else { <div class="chatlog__embed-author">@embed.Author.Name</div> } } </div> } @* Embed title *@ @if (!string.IsNullOrWhiteSpace(embed.Title)) { <div class="chatlog__embed-title"> @if (!string.IsNullOrWhiteSpace(embed.Url)) { <a class="chatlog__embed-title-link" href="@embed.Url"> <div class="chatlog__markdown chatlog__markdown-preserve"><!--wmm:ignore-->@Html.Raw(await FormatEmbedMarkdownAsync(embed.Title))<!--/wmm:ignore--></div> </a> } else { <div class="chatlog__markdown chatlog__markdown-preserve"><!--wmm:ignore-->@Html.Raw(await FormatEmbedMarkdownAsync(embed.Title))<!--/wmm:ignore--></div> } </div> } @* Video player *@ <div class="chatlog__embed-youtube-container"> <iframe class="chatlog__embed-youtube" src="@youTubeVideoEmbed.Url" width="400" height="225"></iframe> </div> </div> </div> </div> </div> } // Generic image embed else if (embed.Kind == EmbedKind.Image && !string.IsNullOrWhiteSpace(embed.Url)) { var embedImageUrl = embed.Image?.ProxyUrl ?? embed.Image?.Url ?? embed.Thumbnail?.ProxyUrl ?? embed.Thumbnail?.Url ?? embed.Url; <div class="chatlog__embed"> <a href="@await ResolveAssetUrlAsync(embedImageUrl)"> <img class="chatlog__embed-generic-image" src="@await ResolveAssetUrlAsync(embedImageUrl)" alt="Embedded image" loading="lazy"> </a> </div> } // Generic video embed else if (embed.Kind == EmbedKind.Video && !string.IsNullOrWhiteSpace(embed.Url) // Twitch clips cannot be embedded in local HTML files && embed.TryGetTwitchClip() is null) { var embedVideoUrl = embed.Video?.ProxyUrl ?? embed.Video?.Url ?? embed.Url; <div class="chatlog__embed"> <video class="chatlog__embed-generic-video" width="@embed.Video?.Width" height="@embed.Video?.Height" controls> <source src="@await ResolveAssetUrlAsync(embedVideoUrl)" alt="Embedded video"> </video> </div> } // Generic gifv embed else if (embed.Kind == EmbedKind.Gifv && !string.IsNullOrWhiteSpace(embed.Url)) { var embedVideoUrl = embed.Video?.ProxyUrl ?? embed.Video?.Url ?? embed.Url; <div class="chatlog__embed"> <video class="chatlog__embed-generic-gifv" width="@embed.Video?.Width" height="@embed.Video?.Height" loop onmouseover="this.play()" onmouseout="this.pause()"> <source src="@await ResolveAssetUrlAsync(embedVideoUrl)" alt="Embedded gifv"> </video> </div> } // Rich embed else { <div class="chatlog__embed"> @* Color pill *@ @if (embed.Color is not null) { <div class="chatlog__embed-color-pill" style="background-color: rgba(@embed.Color.Value.R, @embed.Color.Value.G, @embed.Color.Value.B, @embed.Color.Value.A)"></div> } else { <div class="chatlog__embed-color-pill chatlog__embed-color-pill--default"></div> } <div class="chatlog__embed-content-container"> <div class="chatlog__embed-content"> <div class="chatlog__embed-text"> @* Embed author *@ @if (embed.Author is not null) { <div class="chatlog__embed-author-container"> @if (!string.IsNullOrWhiteSpace(embed.Author.IconUrl)) { <img class="chatlog__embed-author-icon" src="@await ResolveAssetUrlAsync(embed.Author.IconProxyUrl ?? embed.Author.IconUrl)" alt="Author icon" loading="lazy" onerror="this.style.visibility='hidden'"> } @if (!string.IsNullOrWhiteSpace(embed.Author.Name)) { if (!string.IsNullOrWhiteSpace(embed.Author.Url)) { <a class="chatlog__embed-author-link" href="@embed.Author.Url"> <div class="chatlog__embed-author">@embed.Author.Name</div> </a> } else { <div class="chatlog__embed-author">@embed.Author.Name</div> } } </div> } @* Embed title *@ @if (!string.IsNullOrWhiteSpace(embed.Title)) { <div class="chatlog__embed-title"> @if (!string.IsNullOrWhiteSpace(embed.Url)) { <a class="chatlog__embed-title-link" href="@embed.Url"> <div class="chatlog__markdown chatlog__markdown-preserve"><!--wmm:ignore-->@Html.Raw(await FormatEmbedMarkdownAsync(embed.Title))<!--/wmm:ignore--></div> </a> } else { <div class="chatlog__markdown chatlog__markdown-preserve"><!--wmm:ignore-->@Html.Raw(await FormatEmbedMarkdownAsync(embed.Title))<!--/wmm:ignore--></div> } </div> } @* Embed description *@ @if (!string.IsNullOrWhiteSpace(embed.Description)) { <div class="chatlog__embed-description"> <div class="chatlog__markdown chatlog__markdown-preserve"><!--wmm:ignore-->@Html.Raw(await FormatEmbedMarkdownAsync(embed.Description))<!--/wmm:ignore--></div> </div> } @* Embed fields *@ @if (embed.Fields.Any()) { <div class="chatlog__embed-fields"> @foreach (var field in embed.Fields) { <div class="chatlog__embed-field @(field.IsInline ? "chatlog__embed-field--inline" : null)"> @if (!string.IsNullOrWhiteSpace(field.Name)) { <div class="chatlog__embed-field-name"> <div class="chatlog__markdown chatlog__markdown-preserve"><!--wmm:ignore-->@Html.Raw(await FormatEmbedMarkdownAsync(field.Name))<!--/wmm:ignore--></div> </div> } @if (!string.IsNullOrWhiteSpace(field.Value)) { <div class="chatlog__embed-field-value"> <div class="chatlog__markdown chatlog__markdown-preserve"><!--wmm:ignore-->@Html.Raw(await FormatEmbedMarkdownAsync(field.Value))<!--/wmm:ignore--></div> </div> } </div> } </div> } </div> @* Embed content *@ @if (embed.Thumbnail is not null && !string.IsNullOrWhiteSpace(embed.Thumbnail.Url)) { <div class="chatlog__embed-thumbnail-container"> <a class="chatlog__embed-thumbnail-link" href="@await ResolveAssetUrlAsync(embed.Thumbnail.ProxyUrl ?? embed.Thumbnail.Url)"> <img class="chatlog__embed-thumbnail" src="@await ResolveAssetUrlAsync(embed.Thumbnail.ProxyUrl ?? embed.Thumbnail.Url)" alt="Thumbnail" loading="lazy"> </a> </div> } </div> @* Embed images *@ @if (embed.Images.Any()) { <div class="chatlog__embed-images @(embed.Images.Count == 1 ? "chatlog__embed-images--single" : null)"> @foreach (var image in embed.Images) { if (!string.IsNullOrWhiteSpace(image.Url)) { <div class="chatlog__embed-image-container"> <a class="chatlog__embed-image-link" href="@await ResolveAssetUrlAsync(image.ProxyUrl ?? image.Url)"> <img class="chatlog__embed-image" src="@await ResolveAssetUrlAsync(image.ProxyUrl ?? image.Url)" alt="Image" loading="lazy"> </a> </div> } } </div> } @* Embed footer & icon *@ @if (embed.Footer is not null || embed.Timestamp is not null) { <div class="chatlog__embed-footer"> @* Footer icon *@ @if (!string.IsNullOrWhiteSpace(embed.Footer?.IconUrl)) { <img class="chatlog__embed-footer-icon" src="@await ResolveAssetUrlAsync(embed.Footer.IconProxyUrl ?? embed.Footer.IconUrl)" alt="Footer icon" loading="lazy"> } <span class="chatlog__embed-footer-text"> @* Footer text *@ @if (!string.IsNullOrWhiteSpace(embed.Footer?.Text)) { @embed.Footer.Text } @if (!string.IsNullOrWhiteSpace(embed.Footer?.Text) && embed.Timestamp is not null) { @(" • ") } @* Embed timestamp *@ @if (embed.Timestamp is not null) { @FormatDate(embed.Timestamp.Value) } </span> </div> } </div> </div> } } @* Stickers *@ @foreach (var sticker in message.Stickers) { <div class="chatlog__sticker" title="@sticker.Name"> @if (sticker.IsImage) { <img class="chatlog__sticker--media" src="@await ResolveAssetUrlAsync(sticker.SourceUrl)" alt="Sticker"> } else if (sticker.Format == StickerFormat.Lottie) { <div class="chatlog__sticker--media" data-source="@await ResolveAssetUrlAsync(sticker.SourceUrl)"></div> } </div> } @* Message reactions *@ @if (message.Reactions.Any()) { <div class="chatlog__reactions"> @foreach (var reaction in message.Reactions) { <div class="chatlog__reaction" title="@reaction.Emoji.Code"> <img class="chatlog__emoji chatlog__emoji--small" alt="@reaction.Emoji.Name" src="@await ResolveAssetUrlAsync(reaction.Emoji.ImageUrl)" loading="lazy"> <span class="chatlog__reaction-count">@reaction.Count</span> </div> } </div> } </div> } </div> </div> } </div>
```

# Exporting/MessageWriter.cs

```cs
using System; using System.IO; using System.Threading; using System.Threading.Tasks; using DiscordChatExporter.Core.Discord.Data; namespace DiscordChatExporter.Core.Exporting; internal abstract class MessageWriter(Stream stream, ExportContext context) : IAsyncDisposable { protected Stream Stream { get; } = stream; protected ExportContext Context { get; } = context; public long MessagesWritten { get; private set; } public long BytesWritten => Stream.Length; public virtual ValueTask WritePreambleAsync(CancellationToken cancellationToken = default) => default; public virtual ValueTask WriteMessageAsync( Message message, CancellationToken cancellationToken = default ) { MessagesWritten++; return default; } public virtual ValueTask WritePostambleAsync(CancellationToken cancellationToken = default) => default; public virtual async ValueTask DisposeAsync() => await Stream.DisposeAsync(); }
```

# Exporting/Partitioning/FileSizePartitionLimit.cs

```cs
namespace DiscordChatExporter.Core.Exporting.Partitioning; internal class FileSizePartitionLimit(long limit) : PartitionLimit { public override bool IsReached(long messagesWritten, long bytesWritten) => bytesWritten >= limit; }
```

# Exporting/Partitioning/MessageCountPartitionLimit.cs

```cs
namespace DiscordChatExporter.Core.Exporting.Partitioning; internal class MessageCountPartitionLimit(long limit) : PartitionLimit { public override bool IsReached(long messagesWritten, long bytesWritten) => messagesWritten >= limit; }
```

# Exporting/Partitioning/NullPartitionLimit.cs

```cs
namespace DiscordChatExporter.Core.Exporting.Partitioning; internal class NullPartitionLimit : PartitionLimit { public override bool IsReached(long messagesWritten, long bytesWritten) => false; }
```

# Exporting/Partitioning/PartitionLimit.cs

```cs
using System; using System.Globalization; using System.Text.RegularExpressions; namespace DiscordChatExporter.Core.Exporting.Partitioning; public abstract partial class PartitionLimit { public abstract bool IsReached(long messagesWritten, long bytesWritten); } public partial class PartitionLimit { public static PartitionLimit Null { get; } = new NullPartitionLimit(); private static long? TryParseFileSizeBytes(string value, IFormatProvider? formatProvider = null) { var match = Regex.Match(value, @"^\s*(\d+[\.,]?\d*)\s*(\w)?b\s*$", RegexOptions.IgnoreCase); // Number part if ( !double.TryParse( match.Groups[1].Value, NumberStyles.Float, formatProvider, out var number ) ) { return null; } // Magnitude part var magnitude = match.Groups[2].Value.ToUpperInvariant() switch { "G" => 1_000_000_000, "M" => 1_000_000, "K" => 1_000, "" => 1, _ => -1, }; if (magnitude < 0) { return null; } return (long)(number * magnitude); } public static PartitionLimit? TryParse(string value, IFormatProvider? formatProvider = null) { var fileSizeLimit = TryParseFileSizeBytes(value, formatProvider); if (fileSizeLimit is not null) return new FileSizePartitionLimit(fileSizeLimit.Value); if (int.TryParse(value, NumberStyles.Integer, formatProvider, out var messageCountLimit)) return new MessageCountPartitionLimit(messageCountLimit); return null; } public static PartitionLimit Parse(string value, IFormatProvider? formatProvider = null) => TryParse(value, formatProvider) ?? throw new FormatException($"Invalid partition limit '{value}'."); }
```

# Exporting/PlainTextMarkdownVisitor.cs

```cs
using System.Text; using System.Threading; using System.Threading.Tasks; using DiscordChatExporter.Core.Markdown; using DiscordChatExporter.Core.Markdown.Parsing; using DiscordChatExporter.Core.Utils.Extensions; namespace DiscordChatExporter.Core.Exporting; internal partial class PlainTextMarkdownVisitor(ExportContext context, StringBuilder buffer) : MarkdownVisitor { protected override ValueTask VisitTextAsync( TextNode text, CancellationToken cancellationToken = default ) { buffer.Append(text.Text); return default; } protected override ValueTask VisitEmojiAsync( EmojiNode emoji, CancellationToken cancellationToken = default ) { buffer.Append(emoji.IsCustomEmoji ? $":{emoji.Name}:" : emoji.Name); return default; } protected override async ValueTask VisitMentionAsync( MentionNode mention, CancellationToken cancellationToken = default ) { if (mention.Kind == MentionKind.Everyone) { buffer.Append("@everyone"); } else if (mention.Kind == MentionKind.Here) { buffer.Append("@here"); } else if (mention.Kind == MentionKind.User) { // User mentions are not always included in the message object, // which means they need to be populated on demand. // https://github.com/Tyrrrz/DiscordChatExporter/issues/304 if (mention.TargetId is not null) await context.PopulateMemberAsync(mention.TargetId.Value, cancellationToken); var member = mention.TargetId?.Pipe(context.TryGetMember); var displayName = member?.DisplayName ?? member?.User.DisplayName ?? "Unknown"; buffer.Append($"@{displayName}"); } else if (mention.Kind == MentionKind.Channel) { var channel = mention.TargetId?.Pipe(context.TryGetChannel); var name = channel?.Name ?? "deleted-channel"; buffer.Append($"#{name}"); // Voice channel marker if (channel?.IsVoice == true) buffer.Append(" [voice]"); } else if (mention.Kind == MentionKind.Role) { var role = mention.TargetId?.Pipe(context.TryGetRole); var name = role?.Name ?? "deleted-role"; buffer.Append($"@{name}"); } } protected override ValueTask VisitTimestampAsync( TimestampNode timestamp, CancellationToken cancellationToken = default ) { buffer.Append( timestamp.Instant is not null ? context.FormatDate(timestamp.Instant.Value, timestamp.Format ?? "g") : "Invalid date" ); return default; } } internal partial class PlainTextMarkdownVisitor { public static async ValueTask<string> FormatAsync( ExportContext context, string markdown, CancellationToken cancellationToken = default ) { var nodes = MarkdownParser.ParseMinimal(markdown); var buffer = new StringBuilder(); await new PlainTextMarkdownVisitor(context, buffer).VisitAsync(nodes, cancellationToken); return buffer.ToString(); } }
```

# Exporting/PlainTextMessageExtensions.cs

```cs
using System.Globalization; using System.Linq; using DiscordChatExporter.Core.Discord.Data; using DiscordChatExporter.Core.Utils.Extensions; namespace DiscordChatExporter.Core.Exporting; internal static class PlainTextMessageExtensions { public static string GetFallbackContent(this Message message) => message.Kind switch { MessageKind.RecipientAdd => message.MentionedUsers.Any() ? $"Added {message.MentionedUsers.First().DisplayName} to the group." : "Added a recipient.", MessageKind.RecipientRemove => message.MentionedUsers.Any() ? message.Author.Id == message.MentionedUsers.First().Id ? "Left the group." : $"Removed {message.MentionedUsers.First().DisplayName} from the group." : "Removed a recipient.", MessageKind.Call => $"Started a call that lasted { message .CallEndedTimestamp? .Pipe(t => t - message.Timestamp) .Pipe(t => t.TotalMinutes) .ToString("n0", CultureInfo.InvariantCulture) ?? "0" } minutes.", MessageKind.ChannelNameChange => !string.IsNullOrWhiteSpace(message.Content) ? $"Changed the channel name: {message.Content}" : "Changed the channel name.", MessageKind.ChannelIconChange => "Changed the channel icon.", MessageKind.ChannelPinnedMessage => "Pinned a message.", MessageKind.ThreadCreated => "Started a thread.", MessageKind.GuildMemberJoin => "Joined the server.", _ => message.Content, }; }
```

# Exporting/PlainTextMessageWriter.cs

```cs
using System.Collections.Generic; using System.IO; using System.Linq; using System.Threading; using System.Threading.Tasks; using DiscordChatExporter.Core.Discord.Data; using DiscordChatExporter.Core.Discord.Data.Embeds; using DiscordChatExporter.Core.Utils.Extensions; namespace DiscordChatExporter.Core.Exporting; internal class PlainTextMessageWriter(Stream stream, ExportContext context) : MessageWriter(stream, context) { private readonly TextWriter _writer = new StreamWriter(stream); private async ValueTask<string> FormatMarkdownAsync( string markdown, CancellationToken cancellationToken = default ) => Context.Request.ShouldFormatMarkdown ? await PlainTextMarkdownVisitor.FormatAsync(Context, markdown, cancellationToken) : markdown; private async ValueTask WriteMessageHeaderAsync(Message message) { // Timestamp & author await _writer.WriteAsync($"[{Context.FormatDate(message.Timestamp)}]"); await _writer.WriteAsync($" {message.Author.FullName}"); // Whether the message is pinned if (message.IsPinned) await _writer.WriteAsync(" (pinned)"); await _writer.WriteLineAsync(); } private async ValueTask WriteAttachmentsAsync( IReadOnlyList<Attachment> attachments, CancellationToken cancellationToken = default ) { if (!attachments.Any()) return; await _writer.WriteLineAsync("{Attachments}"); foreach (var attachment in attachments) { cancellationToken.ThrowIfCancellationRequested(); await _writer.WriteLineAsync( await Context.ResolveAssetUrlAsync(attachment.Url, cancellationToken) ); } await _writer.WriteLineAsync(); } private async ValueTask WriteEmbedsAsync( IReadOnlyList<Embed> embeds, CancellationToken cancellationToken = default ) { foreach (var embed in embeds) { cancellationToken.ThrowIfCancellationRequested(); await _writer.WriteLineAsync("{Embed}"); if (!string.IsNullOrWhiteSpace(embed.Author?.Name)) { await _writer.WriteLineAsync(embed.Author.Name); } if (!string.IsNullOrWhiteSpace(embed.Url)) { await _writer.WriteLineAsync(embed.Url); } if (!string.IsNullOrWhiteSpace(embed.Title)) { await _writer.WriteLineAsync( await FormatMarkdownAsync(embed.Title, cancellationToken) ); } if (!string.IsNullOrWhiteSpace(embed.Description)) { await _writer.WriteLineAsync( await FormatMarkdownAsync(embed.Description, cancellationToken) ); } foreach (var field in embed.Fields) { if (!string.IsNullOrWhiteSpace(field.Name)) { await _writer.WriteLineAsync( await FormatMarkdownAsync(field.Name, cancellationToken) ); } if (!string.IsNullOrWhiteSpace(field.Value)) { await _writer.WriteLineAsync( await FormatMarkdownAsync(field.Value, cancellationToken) ); } } if (!string.IsNullOrWhiteSpace(embed.Thumbnail?.Url)) { await _writer.WriteLineAsync( await Context.ResolveAssetUrlAsync( embed.Thumbnail.ProxyUrl ?? embed.Thumbnail.Url, cancellationToken ) ); } foreach (var image in embed.Images) { if (!string.IsNullOrWhiteSpace(image.Url)) { await _writer.WriteLineAsync( await Context.ResolveAssetUrlAsync( image.ProxyUrl ?? image.Url, cancellationToken ) ); } } if (!string.IsNullOrWhiteSpace(embed.Footer?.Text)) { await _writer.WriteLineAsync(embed.Footer.Text); } await _writer.WriteLineAsync(); } } private async ValueTask WriteStickersAsync( IReadOnlyList<Sticker> stickers, CancellationToken cancellationToken = default ) { if (!stickers.Any()) return; await _writer.WriteLineAsync("{Stickers}"); foreach (var sticker in stickers) { cancellationToken.ThrowIfCancellationRequested(); await _writer.WriteLineAsync( await Context.ResolveAssetUrlAsync(sticker.SourceUrl, cancellationToken) ); } await _writer.WriteLineAsync(); } private async ValueTask WriteReactionsAsync( IReadOnlyList<Reaction> reactions, CancellationToken cancellationToken = default ) { if (!reactions.Any()) return; await _writer.WriteLineAsync("{Reactions}"); foreach (var (reaction, i) in reactions.WithIndex()) { cancellationToken.ThrowIfCancellationRequested(); if (i > 0) { await _writer.WriteAsync(' '); } await _writer.WriteAsync(reaction.Emoji.Name); if (reaction.Count > 1) { await _writer.WriteAsync($" ({reaction.Count})"); } } await _writer.WriteLineAsync(); } public override async ValueTask WritePreambleAsync( CancellationToken cancellationToken = default ) { await _writer.WriteLineAsync(new string('=', 62)); await _writer.WriteLineAsync($"Guild: {Context.Request.Guild.Name}"); await _writer.WriteLineAsync($"Channel: {Context.Request.Channel.GetHierarchicalName()}"); if (!string.IsNullOrWhiteSpace(Context.Request.Channel.Topic)) { await _writer.WriteLineAsync($"Topic: {Context.Request.Channel.Topic}"); } if (Context.Request.After is not null) { await _writer.WriteLineAsync( $"After: {Context.FormatDate(Context.Request.After.Value.ToDate())}" ); } if (Context.Request.Before is not null) { await _writer.WriteLineAsync( $"Before: {Context.FormatDate(Context.Request.Before.Value.ToDate())}" ); } await _writer.WriteLineAsync(new string('=', 62)); await _writer.WriteLineAsync(); } public override async ValueTask WriteMessageAsync( Message message, CancellationToken cancellationToken = default ) { await base.WriteMessageAsync(message, cancellationToken); // Header await WriteMessageHeaderAsync(message); // Content if (message.IsSystemNotification) { await _writer.WriteLineAsync(message.GetFallbackContent()); } else { await _writer.WriteLineAsync( await FormatMarkdownAsync(message.Content, cancellationToken) ); } await _writer.WriteLineAsync(); // Attachments, embeds, reactions, etc. await WriteAttachmentsAsync(message.Attachments, cancellationToken); await WriteEmbedsAsync(message.Embeds, cancellationToken); await WriteStickersAsync(message.Stickers, cancellationToken); await WriteReactionsAsync(message.Reactions, cancellationToken); await _writer.WriteLineAsync(); } public override async ValueTask WritePostambleAsync( CancellationToken cancellationToken = default ) { await _writer.WriteLineAsync(new string('=', 62)); await _writer.WriteLineAsync($"Exported {MessagesWritten:N0} message(s)"); await _writer.WriteLineAsync(new string('=', 62)); } public override async ValueTask DisposeAsync() { await _writer.DisposeAsync(); await base.DisposeAsync(); } }
```

# Exporting/PostambleTemplate.cshtml

```cshtml
@using System @inherits RazorBlade.HtmlTemplate @functions { public required ExportContext Context { get; init; } public required long MessagesWritten { get; init; } } @{ /* Close elements opened by preamble */ } <!--wmm:ignore--> </div> <!--/wmm:ignore--> <div class="postamble"> <div class="postamble__entry">Exported @MessagesWritten.ToString("n0", Context.Request.CultureInfo) message(s)</div> <div class="postamble__entry">Timezone: UTC@((Context.Request.IsUtcNormalizationEnabled ? 0 : TimeZoneInfo.Local.BaseUtcOffset.TotalHours).ToString("+#.#;-#.#;+0", Context.Request.CultureInfo))</div> </div> </body> </html>
```

# Exporting/PreambleTemplate.cshtml

```cshtml
@using System @using System.Threading.Tasks @inherits RazorBlade.HtmlTemplate @functions { public required ExportContext Context { get; init; } public required string ThemeName { get; init; } } @{ string Themed(string darkVariant, string lightVariant) => string.Equals(ThemeName, "Dark", StringComparison.OrdinalIgnoreCase) ? darkVariant : lightVariant; string GetFontUrl(string style, int weight) => $"https://cdn.jsdelivr.net/gh/Tyrrrz/DiscordFonts@master/ggsans-{style}-{weight}.woff2"; ValueTask<string> ResolveAssetUrlAsync(string url) => Context.ResolveAssetUrlAsync(url, CancellationToken); string FormatDate(DateTimeOffset instant, string format = "g") => Context.FormatDate(instant, format); async ValueTask<string> FormatMarkdownAsync(string markdown) => Context.Request.ShouldFormatMarkdown ? await HtmlMarkdownVisitor.FormatAsync(Context, markdown, true, CancellationToken) : markdown; } <!DOCTYPE html> <html lang="en"> <head> <title>@Context.Request.Guild.Name - @Context.Request.Channel.Name</title> <meta charset="utf-8"> <meta name="viewport" content="width=device-width"> @* Styling *@ <style> @@font-face { src: url("@await ResolveAssetUrlAsync(GetFontUrl("normal", 400))"); font-family: gg sans; font-weight: 400; font-style: normal; } @@font-face { src: url("@await ResolveAssetUrlAsync(GetFontUrl("normal", 500))"); font-family: gg sans; font-weight: 500; font-style: normal; } @@font-face { src: url("@await ResolveAssetUrlAsync(GetFontUrl("normal", 600))"); font-family: gg sans; font-weight: 600; font-style: normal; } @@font-face { src: url("@await ResolveAssetUrlAsync(GetFontUrl("normal", 700))"); font-family: gg sans; font-weight: 700; font-style: normal; } @@font-face { src: url("@await ResolveAssetUrlAsync(GetFontUrl("normal", 800))"); font-family: gg sans; font-weight: 800; font-style: normal; } @@font-face { src: url("@await ResolveAssetUrlAsync(GetFontUrl("italic", 400))"); font-family: gg sans; font-weight: 400; font-style: italic; } @@font-face { src: url("@await ResolveAssetUrlAsync(GetFontUrl("italic", 500))"); font-family: gg sans; font-weight: 500; font-style: italic; } @@font-face { src: url("@await ResolveAssetUrlAsync(GetFontUrl("italic", 600))"); font-family: gg sans; font-weight: 600; font-style: italic; } @@font-face { src: url("@await ResolveAssetUrlAsync(GetFontUrl("italic", 700))"); font-family: gg sans; font-weight: 700; font-style: italic; } @@font-face { src: url("@await ResolveAssetUrlAsync(GetFontUrl("italic", 800))"); font-family: gg sans; font-weight: 800; font-style: italic; } html, body { margin: 0; padding: 0; background-color: @Themed("#36393e", "#ffffff"); color: @Themed("#dcddde", "#23262a"); font-family: "gg sans", "Helvetica Neue", Helvetica, Arial, sans-serif; font-size: 17px; font-weight: @Themed("400", "500"); scroll-behavior: smooth; } a { color: @Themed("#00aff4", "#0068e0"); text-decoration: none; } a:hover { text-decoration: underline; } img { object-fit: contain; image-rendering: high-quality; image-rendering: -webkit-optimize-contrast; } .preamble { display: grid; grid-template-columns: auto 1fr; max-width: 100%; padding: 1rem; } .preamble__guild-icon-container { grid-column: 1; } .preamble__guild-icon { max-width: 88px; max-height: 88px; } .preamble__entries-container { grid-column: 2; margin-left: 1rem; } .preamble__entry { margin-bottom: 0.15rem; color: @Themed("#ffffff", "#2f3136"); font-size: 1.4rem; } .preamble__entry--small { font-size: 1rem; } .chatlog { padding: 1rem 0; width: 100%; border-top: 1px solid @Themed("rgba(255, 255, 255, 0.1)", "#eceeef"); border-bottom: 1px solid @Themed("rgba(255, 255, 255, 0.1)", "#eceeef"); } .chatlog__message-group { margin-bottom: 1rem; } .chatlog__message-container { background-color: transparent; transition: background-color 1s ease; } .chatlog__message-container--highlighted { background-color: @Themed("rgba(114, 137, 218, 0.2)", "rgba(114, 137, 218, 0.2)"); } .chatlog__message-container--pinned { background-color: @Themed("rgba(249, 168, 37, 0.05)", "rgba(249, 168, 37, 0.05)"); } .chatlog__message { display: grid; grid-template-columns: auto 1fr; padding: 0.15rem 0; direction: ltr; unicode-bidi: bidi-override; } .chatlog__message:hover { background-color: @Themed("#32353b", "#fafafa"); } .chatlog__message:hover .chatlog__short-timestamp { display: block; } .chatlog__message-aside { grid-column: 1; width: 72px; padding: 0.15rem 0.15rem 0 0.15rem; text-align: center; } .chatlog__reply-symbol { height: 10px; margin: 6px 4px 4px 36px; border-left: 2px solid @Themed("#4f545c", "#c7ccd1"); border-top: 2px solid @Themed("#4f545c", "#c7ccd1"); border-radius: 8px 0 0 0; } .chatlog__avatar { width: 40px; height: 40px; border-radius: 50%; } .chatlog__short-timestamp { display: none; color: @Themed("#a3a6aa", "#5e6772"); font-size: 0.75rem; font-weight: 500; direction: ltr; unicode-bidi: bidi-override; } .chatlog__message-primary { grid-column: 2; min-width: 0; } .chatlog__reply { display: flex; margin-bottom: 0.15rem; align-items: center; color: @Themed("#b5b6b8", "#5f5f60"); font-size: 0.875rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; } .chatlog__reply-avatar { width: 16px; height: 16px; margin-right: 0.25rem; border-radius: 50%; } .chatlog__reply-author { margin-right: 0.3rem; font-weight: 600; } .chatlog__reply-content { overflow: hidden; text-overflow: ellipsis; } .chatlog__reply-link { cursor: pointer; } .chatlog__reply-link * { display: inline; pointer-events: none; } .chatlog__reply-link .chatlog__markdown-quote { display: inline; } .chatlog__reply-link .chatlog__markdown-pre { display: inline; } .chatlog__reply-link:hover { color: @Themed("#ffffff", "#2f3136"); } .chatlog__reply-link:hover *:not(.chatlog__markdown-spoiler) { color: inherit; } .chatlog__reply-edited-timestamp { margin-left: 0.25rem; color: @Themed("#a3a6aa", "#5e6772"); font-size: 0.75rem; font-weight: 500; direction: ltr; unicode-bidi: bidi-override; } .chatlog__system-notification-icon { width: 18px; height: 18px; } .chatlog__system-notification-author { font-weight: @Themed("500", "600"); color: @Themed("#ffffff", "#2f3136"); } .chatlog__system-notification-content { color: @Themed("#96989d", "#5e6772") } .chatlog__system-notification-link { font-weight: 500; color: @Themed("#ffffff", "#2f3136"); } .chatlog__system-notification-timestamp { margin-left: 0.3rem; color: @Themed("#a3a6aa", "#5e6772"); font-size: 0.75rem; font-weight: 500; direction: ltr; unicode-bidi: bidi-override; } .chatlog__system-notification-timestamp a { color: inherit; } .chatlog__header { margin-bottom: 0.1rem; } .chatlog__author { font-weight: @Themed("500", "600"); color: @Themed("#ffffff", "#2f3136"); } .chatlog__author-tag { position: relative; top: -0.1rem; margin-left: 0.3rem; padding: 0.05rem 0.3rem; border-radius: 3px; background-color: #5865F2; color: #ffffff; font-size: 0.625rem; font-weight: 500; line-height: 1.3; } .chatlog__timestamp { margin-left: 0.3rem; color: @Themed("#a3a6aa", "#5e6772"); font-size: 0.75rem; font-weight: 500; direction: ltr; unicode-bidi: bidi-override; } .chatlog__timestamp a { color: inherit; } .chatlog__content { padding-right: 1rem; font-size: 0.95rem; word-wrap: break-word; } .chatlog__edited-timestamp { margin-left: 0.15rem; color: @Themed("#a3a6aa", "#5e6772"); font-size: 0.75rem; font-weight: 500; } .chatlog__attachment { position: relative; width: fit-content; margin-top: 0.3rem; border-radius: 3px; overflow: hidden; } .chatlog__attachment--hidden { cursor: pointer; box-shadow: 0 0 1px 1px rgba(0, 0, 0, 0.1); } .chatlog__attachment--hidden * { pointer-events: none; } .chatlog__attachment-spoiler-caption { display: none; position: absolute; left: 50%; top: 50%; z-index: 999; padding: 0.4rem 0.8rem; border-radius: 20px; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.9); color: #dcddde; font-size: 0.9rem; font-weight: 600; letter-spacing: 0.05rem; } .chatlog__attachment--hidden .chatlog__attachment-spoiler-caption { display: block; } .chatlog__attachment--hidden:hover .chatlog__attachment-spoiler-caption { color: #fff; } .chatlog__attachment-media { max-width: 45vw; max-height: 500px; vertical-align: top; border-radius: 3px; } .chatlog__attachment--hidden .chatlog__attachment-media { filter: blur(44px); } .chatlog__attachment-generic { max-width: 520px; width: 100%; height: 40px; padding: 10px; border: 1px solid @Themed("#292b2f", "#ebedef"); border-radius: 3px; background-color: @Themed("#2f3136", "#f2f3f5"); overflow: hidden; } .chatlog__attachment--hidden .chatlog__attachment-generic { filter: blur(44px); } .chatlog__attachment-generic-icon { float: left; width: 30px; height: 100%; margin-right: 10px; } .chatlog__attachment-generic-size { color: #72767d; font-size: 12px; } .chatlog__attachment-generic-name { overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } .chatlog__embed { display: flex; margin-top: 0.3rem; max-width: 520px; } .chatlog__embed-color-pill { flex-shrink: 0; width: 0.25rem; border-top-left-radius: 3px; border-bottom-left-radius: 3px; } .chatlog__embed-color-pill--default { background-color: @Themed("#202225", "rgba(227, 229, 232, 1)"); } .chatlog__embed-content-container { display: flex; flex-direction: column; padding: 0.5rem 0.6rem; border: 1px solid @Themed("rgba(46, 48, 54, 0.6)", "rgba(204, 204, 204, 0.3)"); border-top-right-radius: 3px; border-bottom-right-radius: 3px; background-color: @Themed("rgba(46, 48, 54, 0.3)", "rgba(249, 249, 249, 0.3)"); } .chatlog__embed-content { display: flex; width: 100%; } .chatlog__embed-text { flex: 1; } .chatlog__embed-author-container { display: flex; margin-bottom: 0.5rem; align-items: center; } .chatlog__embed-author-icon { width: 20px; height: 20px; margin-right: 0.5rem; border-radius: 50%; } .chatlog__embed-author { color: @Themed("#ffffff", "#4f545c"); font-size: 0.875rem; font-weight: 600; direction: ltr; unicode-bidi: bidi-override; } .chatlog__embed-author-link { color: @Themed("#ffffff", "#4f545c"); } .chatlog__embed-title { margin-bottom: 0.5rem; color: @Themed("#ffffff", "#4f545c"); font-size: 0.875rem; font-weight: 600; } .chatlog__embed-description { color: @Themed("#dcddde", "#2e3338"); font-weight: 500; font-size: 0.85rem; } .chatlog__embed-fields { display: flex; flex-wrap: wrap; gap: 0 0.5rem; } .chatlog__embed-field { flex: 0; min-width: 100%; max-width: 506px; padding-top: 0.6rem; font-size: 0.875rem; } .chatlog__embed-field--inline { flex: 1; flex-basis: auto; min-width: 50px; } .chatlog__embed-field-name { margin-bottom: 0.2rem; color: @Themed("#ffffff", "#36393e"); font-weight: 600; } .chatlog__embed-field-value { color: @Themed("#dcddde", "#2e3338"); font-weight: 500; } .chatlog__embed-thumbnail { flex: 0; max-width: 80px; max-height: 80px; margin-left: 1.2rem; border-radius: 3px; } .chatlog__embed-images { display: grid; margin-top: 0.6rem; grid-template-columns: repeat(2, 1fr); gap: 0.25rem; } .chatlog__embed-images--single { display: block; } .chatlog__embed-image { object-fit: cover; object-position: center; max-width: 500px; max-height: 400px; width: 100%; height: 100%; border-radius: 3px; } .chatlog__embed-footer { margin-top: 0.6rem; color: @Themed("#dcddde", "#2e3338"); } .chatlog__embed-footer-icon { width: 20px; height: 20px; margin-right: 0.2rem; border-radius: 50%; vertical-align: middle; } .chatlog__embed-footer-text { vertical-align: middle; font-size: 0.75rem; font-weight: 500; } .chatlog__embed-invite-container { min-width: 320px; padding: 0.6rem 0.7rem; border: 1px solid @Themed("rgba(46, 48, 54, 0.6)", "rgba(204, 204, 204, 0.3)"); border-radius: 3px; background-color: @Themed("rgba(46, 48, 54, 0.3)", "rgba(249, 249, 249, 0.3)"); } .chatlog__embed-invite-title { margin: 0 0 0.8rem 0; color: @Themed("#b9bbbe", "#4f5660"); font-size: 0.75rem; font-weight: 700; text-transform: uppercase; } .chatlog__embed-invite { display: flex; } .chatlog__embed-invite-guild-icon { width: 50px; height: 50px; border-radius: 0.85rem; } .chatlog__embed-invite-info { margin-left: 1rem; } .chatlog__embed-invite-guild-name { color: @Themed("#ffffff", "#36393e"); font-weight: 600; } .chatlog__embed-invite-guild-name a { color: inherit; } .chatlog__embed-invite-channel-icon { width: 18px; height: 18px; vertical-align: bottom; } .chatlog__embed-invite-channel-name { font-size: 0.9rem; font-weight: 600; } .chatlog__embed-generic-image { object-fit: contain; object-position: left; max-width: 45vw; max-height: 500px; vertical-align: top; border-radius: 3px; } .chatlog__embed-generic-video { object-fit: contain; object-position: left; max-width: 45vw; max-height: 500px; vertical-align: top; border-radius: 3px; } .chatlog__embed-generic-gifv { object-fit: contain; object-position: left; max-width: 45vw; max-height: 500px; vertical-align: top; border-radius: 3px; } .chatlog__embed-spotify { border: 0; } .chatlog__embed-twitch { border: 0; } .chatlog__embed-youtube-container { margin-top: 0.6rem; } .chatlog__embed-youtube { border: 0; border-radius: 3px; } .chatlog__sticker { width: 180px; height: 180px; } .chatlog__sticker--media { max-width: 100%; max-height: 100%; } .chatlog__reactions { display: flex; } .chatlog__reaction { display: flex; margin: 0.35rem 0.1rem 0.1rem 0; padding: 0.125rem 0.375rem; border: 1px solid transparent; border-radius: 8px; background-color: @Themed("#2f3136", "#f2f3f5"); align-items: center; } .chatlog__reaction:hover { border: 1px solid @Themed("hsla(0,0%,100%,.2)", "rgba(0, 0, 0, 0.2)"); background-color: @Themed("transparent", "white"); } .chatlog__reaction-count { min-width: 9px; margin-left: 0.35rem; color: @Themed("#b9bbbe", "#4f5660"); font-size: 0.875rem; } .chatlog__reaction:hover .chatlog__reaction-count { color: @Themed("#dcddde", "#2e3338"); } .chatlog__markdown { max-width: 100%; line-height: 1.3; overflow-wrap: break-word; } .chatlog__markdown h1 { margin: 1rem 0 0.5rem; color: @Themed("#f2f3f5", "#060607"); font-size: 1.5rem; line-height: 1; } .chatlog__markdown h2 { margin: 1rem 0 0.5rem; color: @Themed("#f2f3f5", "#060607"); font-size: 1.25rem; line-height: 1; } .chatlog__markdown h3 { margin: 1rem 0 0.5rem; color: @Themed("#f2f3f5", "#060607"); font-size: 1rem; line-height: 1; } .chatlog__markdown h1:first-child, h2:first-child, h3:first-child { margin-top: 0.5rem; } .chatlog__markdown ul, ol { margin: 0 0 0 1rem; padding: 0; } .chatlog__markdown-preserve { white-space: pre-wrap; } .chatlog__markdown-spoiler { background-color: @Themed("rgba(255, 255, 255, 0.1)", "rgba(0, 0, 0, 0.1)"); padding: 0 2px; border-radius: 3px; } .chatlog__markdown-spoiler--hidden { cursor: pointer; background-color: @Themed("#202225", "#b9bbbe"); color: rgba(0, 0, 0, 0); } .chatlog__markdown-spoiler--hidden:hover { background-color: @Themed("rgba(32, 34, 37, 0.8)", "rgba(185, 187, 190, 0.8)"); } .chatlog__markdown-spoiler--hidden::selection { color: rgba(0, 0, 0, 0); } .chatlog__markdown-quote { display: flex; margin: 0.05rem 0; } .chatlog__markdown-quote-border { margin-right: 0.5rem; border: 2px solid @Themed("#4f545c", "#c7ccd1"); border-radius: 3px; } .chatlog__markdown-pre { background-color: @Themed("#2f3136", "#f9f9f9"); font-family: "Consolas", "Courier New", Courier, monospace; font-size: 0.85rem; text-decoration: inherit; } .chatlog__markdown-pre--multiline { display: block; margin-top: 0.25rem; padding: 0.5rem; border: 2px solid @Themed("#282b30", "#f3f3f3"); border-radius: 5px; color: @Themed("#b9bbbe", "#657b83"); } .chatlog__markdown-pre--multiline.hljs { background-color: @Themed("#2f3136", "#f9f9f9"); color: @Themed("#b9bbbe", "#657b83"); } .chatlog__markdown-pre--inline { display: inline-block; padding: 2px; border-radius: 3px; } .chatlog__markdown-mention { border-radius: 3px; padding: 0 2px; background-color: @Themed("rgba(88, 101, 242, .3)", "rgba(88, 101, 242, .15)"); color: @Themed("#dee0fc", "#505cdc"); font-weight: 500; } .chatlog__markdown-mention:hover { background-color: #5865f2; color: #ffffff } .chatlog__markdown-timestamp { background-color: @Themed("rgba(255, 255, 255, 0.1)", "rgba(0, 0, 0, 0.1)"); padding: 0 2px; border-radius: 3px; } .chatlog__emoji { width: 1.325rem; height: 1.325rem; margin: 0 0.06rem; vertical-align: -0.4rem; } .chatlog__emoji--small { width: 1rem; height: 1rem; } .chatlog__emoji--large { width: 2.8rem; height: 2.8rem; } .postamble { padding: 1.25rem; } .postamble__entry { color: @Themed("#ffffff", "#2f3136"); } </style> @* Syntax highlighting *@ <link rel="stylesheet" href="@await ResolveAssetUrlAsync($"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/solarized-{ThemeName.ToLowerInvariant()}.min.css")"> <script src="@await ResolveAssetUrlAsync("https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js")"></script> <script> document.addEventListener('DOMContentLoaded', () => { document.querySelectorAll('.chatlog__markdown-pre--multiline').forEach(e => hljs.highlightBlock(e)); }); </script> @* Lottie animation support *@ <script src="@await ResolveAssetUrlAsync("https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.8.1/lottie.min.js")"></script> <script> document.addEventListener('DOMContentLoaded', () => { document.querySelectorAll('.chatlog__sticker--media[data-source]').forEach(e => { const anim = lottie.loadAnimation({ container: e, renderer: 'svg', loop: true, autoplay: true, path: e.getAttribute('data-source') }); anim.addEventListener( 'data_failed', () => e.innerHTML = '<strong>[Sticker cannot be rendered]</strong>' ); }); }); </script> @* Scripts *@ <script> function scrollToMessage(event, id) { const element = document.getElementById('chatlog__message-container-' + id); if (!element) return; event.preventDefault(); element.classList.add('chatlog__message-container--highlighted'); window.scrollTo({ top: element.getBoundingClientRect().top - document.body.getBoundingClientRect().top - (window.innerHeight / 2), behavior: 'smooth' }); window.setTimeout( () => element.classList.remove('chatlog__message-container--highlighted'), 2000 ); } function showSpoiler(event, element) { if (!element) return; if (element.classList.contains('chatlog__attachment--hidden')) { event.preventDefault(); element.classList.remove('chatlog__attachment--hidden'); } if (element.classList.contains('chatlog__markdown-spoiler--hidden')) { event.preventDefault(); element.classList.remove('chatlog__markdown-spoiler--hidden'); } } </script> @* Icons *@ <svg style="display: none" xmlns="http://www.w3.org/2000/svg"> <defs> <symbol id="attachment-icon" viewBox="0 0 720 960"> <path fill="#f4f5fb" d="M50,935a25,25,0,0,1-25-25V50A25,25,0,0,1,50,25H519.6L695,201.32V910a25,25,0,0,1-25,25Z" /> <path fill="#7789c4" d="M509.21,50,670,211.63V910H50V50H509.21M530,0H50A50,50,0,0,0,0,50V910a50,50,0,0,0,50,50H670a50,50,0,0,0,50-50h0V191Z" /> <path fill="#f4f5fb" d="M530,215a25,25,0,0,1-25-25V50a25,25,0,0,1,16.23-23.41L693.41,198.77A25,25,0,0,1,670,215Z" /> <path fill="#7789c4" d="M530,70.71,649.29,190H530V70.71M530,0a50,50,0,0,0-50,50V190a50,50,0,0,0,50,50H670a50,50,0,0,0,50-50Z" /> </symbol> <symbol id="join-icon" viewBox="0 0 18 18"> <path fill="#3ba55c" d="m0 8h14.2l-3.6-3.6 1.4-1.4 6 6-6 6-1.4-1.4 3.6-3.6h-14.2" /> </symbol> <symbol id="leave-icon" viewBox="0 0 18 18"> <path fill="#ed4245" d="m3.8 8 3.6-3.6-1.4-1.4-6 6 6 6 1.4-1.4-3.6-3.6h14.2v-2" /> </symbol> <symbol id="call-icon" viewBox="0 0 18 18"> <path fill="#3ba55c" fill-rule="evenodd" d="M17.7163041 15.36645368c-.0190957.02699568-1.9039523 2.6680735-2.9957762 2.63320406-3.0676659-.09785935-6.6733809-3.07188394-9.15694343-5.548738C3.08002193 9.9740657.09772497 6.3791404 0 3.3061316v-.024746C0 2.2060575 2.61386252.3152347 2.64082114.2972376c.7110335-.4971705 1.4917101-.3149497 1.80959713.1372281.19320342.2744561 2.19712724 3.2811005 2.42290565 3.6489167.09884826.1608492.14714912.3554431.14714912.5702838 0 .2744561-.07975258.5770327-.23701117.8751101-.1527655.2902036-.65262318 1.1664385-.89862055 1.594995.2673396.3768148.94804468 1.26429792 2.351016 2.66357424 1.39173858 1.39027775 2.28923588 2.07641807 2.67002628 2.34187563.4302146-.2452108 1.3086162-.74238132 1.5972981-.89423205.5447887-.28682915 1.0907006-.31944893 1.4568885-.08661115.3459689.2182151 3.3383754 2.21027167 3.6225641 2.41611376.2695862.19234426.4144887.5399137.4144887.91672846 0 .2969525-.089862.61190215-.2808189.88523346" /> </symbol> <symbol id="pencil-icon" viewBox="0 0 18 18"> <path fill="#99aab5" d="m0 14.25v3.75h3.75l11.06-11.06-3.75-3.75zm17.71-10.21c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75z" /> </symbol> <symbol id="pin-icon" viewBox="0 0 18 18"> <path fill="#b9bbbe" d="m16.908 8.39684-8.29587-8.295827-1.18584 1.184157 1.18584 1.18584-4.14834 4.1475v.00167l-1.18583-1.18583-1.185 1.18583 3.55583 3.55502-4.740831 4.74 1.185001 1.185 4.74083-4.74 3.55581 3.555 1.185-1.185-1.185-1.185 4.1475-4.14836h.0009l1.185 1.185z" /> </symbol> <symbol id="channel-icon" viewBox="0 0 24 24"> <path fill="#b9bbbe" d="M5.88657 21C5.57547 21 5.3399 20.7189 5.39427 20.4126L6.00001 17H2.59511C2.28449 17 2.04905 16.7198 2.10259 16.4138L2.27759 15.4138C2.31946 15.1746 2.52722 15 2.77011 15H6.35001L7.41001 9H4.00511C3.69449 9 3.45905 8.71977 3.51259 8.41381L3.68759 7.41381C3.72946 7.17456 3.93722 7 4.18011 7H7.76001L8.39677 3.41262C8.43914 3.17391 8.64664 3 8.88907 3H9.87344C10.1845 3 10.4201 3.28107 10.3657 3.58738L9.76001 7H15.76L16.3968 3.41262C16.4391 3.17391 16.6466 3 16.8891 3H17.8734C18.1845 3 18.4201 3.28107 18.3657 3.58738L17.76 7H21.1649C21.4755 7 21.711 7.28023 21.6574 7.58619L21.4824 8.58619C21.4406 8.82544 21.2328 9 20.9899 9H17.41L16.35 15H19.7549C20.0655 15 20.301 15.2802 20.2474 15.5862L20.0724 16.5862C20.0306 16.8254 19.8228 17 19.5799 17H16L15.3632 20.5874C15.3209 20.8261 15.1134 21 14.8709 21H13.8866C13.5755 21 13.3399 20.7189 13.3943 20.4126L14 17H8.00001L7.36325 20.5874C7.32088 20.8261 7.11337 21 6.87094 21H5.88657ZM9.41045 9L8.35045 15H14.3504L15.4104 9H9.41045Z" /> </symbol> <symbol id="thread-icon" viewBox="0 0 24 24"> <path fill="#b9bbbe" d="M5.43309 21C5.35842 21 5.30189 20.9325 5.31494 20.859L5.99991 17H2.14274C2.06819 17 2.01168 16.9327 2.02453 16.8593L2.33253 15.0993C2.34258 15.0419 2.39244 15 2.45074 15H6.34991L7.40991 9H3.55274C3.47819 9 3.42168 8.93274 3.43453 8.85931L3.74253 7.09931C3.75258 7.04189 3.80244 7 3.86074 7H7.75991L8.45234 3.09903C8.46251 3.04174 8.51231 3 8.57049 3H10.3267C10.4014 3 10.4579 3.06746 10.4449 3.14097L9.75991 7H15.7599L16.4523 3.09903C16.4625 3.04174 16.5123 3 16.5705 3H18.3267C18.4014 3 18.4579 3.06746 18.4449 3.14097L17.7599 7H21.6171C21.6916 7 21.7481 7.06725 21.7353 7.14069L21.4273 8.90069C21.4172 8.95811 21.3674 9 21.3091 9H17.4099L17.0495 11.04H15.05L15.4104 9H9.41035L8.35035 15H10.5599V17H7.99991L7.30749 20.901C7.29732 20.9583 7.24752 21 7.18934 21H5.43309Z" /> <path fill="#b9bbbe" d="M13.4399 12.96C12.9097 12.96 12.4799 13.3898 12.4799 13.92V20.2213C12.4799 20.7515 12.9097 21.1813 13.4399 21.1813H14.3999C14.5325 21.1813 14.6399 21.2887 14.6399 21.4213V23.4597C14.6399 23.6677 14.8865 23.7773 15.0408 23.6378L17.4858 21.4289C17.6622 21.2695 17.8916 21.1813 18.1294 21.1813H22.5599C23.0901 21.1813 23.5199 20.7515 23.5199 20.2213V13.92C23.5199 13.3898 23.0901 12.96 22.5599 12.96H13.4399Z" /> </symbol> </defs> </svg> </head> <body> <div class="preamble"> <div class="preamble__guild-icon-container"> <img class="preamble__guild-icon" src="@await ResolveAssetUrlAsync(Context.Request.Channel.IconUrl ?? Context.Request.Guild.IconUrl)" alt="Guild icon" loading="lazy"> </div> <div class="preamble__entries-container"> <div class="preamble__entry">@Context.Request.Guild.Name</div> <div class="preamble__entry">@Context.Request.Channel.GetHierarchicalName()</div> @if (!string.IsNullOrWhiteSpace(Context.Request.Channel.Topic)) { <div class="preamble__entry preamble__entry--small">@Html.Raw(await FormatMarkdownAsync(Context.Request.Channel.Topic))</div> } @if (Context.Request.After is not null || Context.Request.Before is not null) { <div class="preamble__entry preamble__entry--small"> @if (Context.Request.After is not null && Context.Request.Before is not null) { @($"Between {FormatDate(Context.Request.After.Value.ToDate())} and {FormatDate(Context.Request.Before.Value.ToDate())}") } else if (Context.Request.After is not null) { @($"After {FormatDate(Context.Request.After.Value.ToDate())}") } else if (Context.Request.Before is not null) { @($"Before {FormatDate(Context.Request.Before.Value.ToDate())}") } </div> } </div> </div> @* Preamble cuts off at this point *@ <!--wmm:ignore--> <div class="chatlog"> <!--/wmm:ignore-->
```

# Markdown/EmojiNode.cs

```cs
using DiscordChatExporter.Core.Discord; using DiscordChatExporter.Core.Utils; namespace DiscordChatExporter.Core.Markdown; internal record EmojiNode( // Only present on custom emoji Snowflake? Id, // Name of a custom emoji (e.g. LUL) or actual representation of a standard emoji (e.g. 🙂) string Name, bool IsAnimated ) : MarkdownNode { public bool IsCustomEmoji => Id is not null; // Name of a custom emoji (e.g. LUL) or name of a standard emoji (e.g. slight_smile) public string Code => IsCustomEmoji ? Name : EmojiIndex.TryGetCode(Name) ?? Name; public EmojiNode(string name) : this(null, name, false) { } }
```

# Markdown/FormattingKind.cs

```cs
namespace DiscordChatExporter.Core.Markdown; internal enum FormattingKind { Bold, Italic, Underline, Strikethrough, Spoiler, Quote, }
```

# Markdown/FormattingNode.cs

```cs
using System.Collections.Generic; namespace DiscordChatExporter.Core.Markdown; internal record FormattingNode(FormattingKind Kind, IReadOnlyList<MarkdownNode> Children) : MarkdownNode, IContainerNode;
```

# Markdown/HeadingNode.cs

```cs
using System.Collections.Generic; namespace DiscordChatExporter.Core.Markdown; internal record HeadingNode(int Level, IReadOnlyList<MarkdownNode> Children) : MarkdownNode, IContainerNode;
```

# Markdown/IContainerNode.cs

```cs
using System.Collections.Generic; namespace DiscordChatExporter.Core.Markdown; internal interface IContainerNode { IReadOnlyList<MarkdownNode> Children { get; } }
```

# Markdown/InlineCodeBlockNode.cs

```cs
namespace DiscordChatExporter.Core.Markdown; internal record InlineCodeBlockNode(string Code) : MarkdownNode;
```

# Markdown/LinkNode.cs

```cs
using System.Collections.Generic; namespace DiscordChatExporter.Core.Markdown; // Named links can contain child nodes (e.g. [**bold URL**](https://test.com)) internal record LinkNode(string Url, IReadOnlyList<MarkdownNode> Children) : MarkdownNode, IContainerNode { public LinkNode(string url) : this(url, [new TextNode(url)]) { } }
```

# Markdown/ListItemNode.cs

```cs
using System.Collections.Generic; namespace DiscordChatExporter.Core.Markdown; internal record ListItemNode(IReadOnlyList<MarkdownNode> Children) : MarkdownNode, IContainerNode;
```

# Markdown/ListNode.cs

```cs
using System.Collections.Generic; namespace DiscordChatExporter.Core.Markdown; internal record ListNode(IReadOnlyList<ListItemNode> Items) : MarkdownNode;
```

# Markdown/MarkdownNode.cs

```cs
namespace DiscordChatExporter.Core.Markdown; internal abstract record MarkdownNode;
```

# Markdown/MentionKind.cs

```cs
namespace DiscordChatExporter.Core.Markdown; internal enum MentionKind { Everyone, Here, User, Channel, Role, }
```

# Markdown/MentionNode.cs

```cs
using DiscordChatExporter.Core.Discord; namespace DiscordChatExporter.Core.Markdown; // Null ID means it's a meta mention or an invalid mention internal record MentionNode(Snowflake? TargetId, MentionKind Kind) : MarkdownNode;
```

# Markdown/MultiLineCodeBlockNode.cs

```cs
namespace DiscordChatExporter.Core.Markdown; internal record MultiLineCodeBlockNode(string Language, string Code) : MarkdownNode;
```

# Markdown/Parsing/AggregateMatcher.cs

```cs
using System.Collections.Generic; namespace DiscordChatExporter.Core.Markdown.Parsing; internal class AggregateMatcher<TContext, TValue>( IReadOnlyList<IMatcher<TContext, TValue>> matchers ) : IMatcher<TContext, TValue> { public AggregateMatcher(params IMatcher<TContext, TValue>[] matchers) : this((IReadOnlyList<IMatcher<TContext, TValue>>)matchers) { } public ParsedMatch<TValue>? TryMatch(TContext context, StringSegment segment) { ParsedMatch<TValue>? earliestMatch = null; // Try to match the input with each matcher and get the match with the lowest start index foreach (var matcher in matchers) { // Try to match var match = matcher.TryMatch(context, segment); // If there's no match - continue if (match is null) continue; // If this match is earlier than previous earliest - replace if ( earliestMatch is null || match.Segment.StartIndex < earliestMatch.Segment.StartIndex ) earliestMatch = match; // If the earliest match starts at the very beginning - break, // because it's impossible to find a match earlier than that if (earliestMatch.Segment.StartIndex == segment.StartIndex) break; } return earliestMatch; } }
```

# Markdown/Parsing/IMatcher.cs

```cs
using System; using System.Collections.Generic; namespace DiscordChatExporter.Core.Markdown.Parsing; internal interface IMatcher<in TContext, TValue> { ParsedMatch<TValue>? TryMatch(TContext context, StringSegment segment); } internal static class MatcherExtensions { public static IEnumerable<ParsedMatch<TValue>> MatchAll<TContext, TValue>( this IMatcher<TContext, TValue> matcher, TContext context, StringSegment segment, Func<TContext, StringSegment, TValue> transformFallback ) { // Loop through segments divided by individual matches var currentIndex = segment.StartIndex; while (currentIndex < segment.EndIndex) { // Find a match within this segment var match = matcher.TryMatch( context, segment.Relocate(currentIndex, segment.EndIndex - currentIndex) ); if (match is null) break; // If this match doesn't start immediately at the current position - transform and yield fallback first if (match.Segment.StartIndex > currentIndex) { var fallbackSegment = segment.Relocate( currentIndex, match.Segment.StartIndex - currentIndex ); yield return new ParsedMatch<TValue>( fallbackSegment, transformFallback(context, fallbackSegment) ); } yield return match; // Shift current index to the end of the match currentIndex = match.Segment.StartIndex + match.Segment.Length; } // If EOL hasn't been reached - transform and yield remaining part as fallback if (currentIndex < segment.EndIndex) { var fallbackSegment = segment.Relocate(currentIndex, segment.EndIndex - currentIndex); yield return new ParsedMatch<TValue>( fallbackSegment, transformFallback(context, fallbackSegment) ); } } }
```

# Markdown/Parsing/MarkdownContext.cs

```cs
namespace DiscordChatExporter.Core.Markdown.Parsing; internal readonly record struct MarkdownContext(int Depth = 0);
```

# Markdown/Parsing/MarkdownParser.cs

```cs
using System; using System.Collections.Generic; using System.Globalization; using System.Linq; using System.Text.RegularExpressions; using DiscordChatExporter.Core.Discord; using DiscordChatExporter.Core.Utils; using DiscordChatExporter.Core.Utils.Extensions; namespace DiscordChatExporter.Core.Markdown.Parsing; // Discord does NOT use a recursive-descent parser for markdown which becomes evident in some // scenarios, like when multiple formatting nodes are nested together. // To replicate Discord's behavior, we're employing a special parser that uses a set of regular // expressions that are executed sequentially in a first-matched-first-served manner. internal static partial class MarkdownParser { private const RegexOptions DefaultRegexOptions = RegexOptions.Compiled | RegexOptions.IgnorePatternWhitespace | RegexOptions.CultureInvariant | RegexOptions.Multiline; /* Formatting */ private static readonly IMatcher<MarkdownContext, MarkdownNode> BoldFormattingNodeMatcher = new RegexMatcher<MarkdownContext, MarkdownNode>( // There must be exactly two closing asterisks. new Regex(@"\*\*(.+?)\*\*(?!\*)", DefaultRegexOptions | RegexOptions.Singleline), (c, s, m) => new FormattingNode(FormattingKind.Bold, Parse(c, s.Relocate(m.Groups[1]))) ); private static readonly IMatcher<MarkdownContext, MarkdownNode> ItalicFormattingNodeMatcher = new RegexMatcher<MarkdownContext, MarkdownNode>( // There must be exactly one closing asterisk. // Opening asterisk must not be followed by whitespace. // Closing asterisk must not be preceded by whitespace. new Regex( @"\*(?!\s)(.+?)(?<!\s|\*)\*(?!\*)", DefaultRegexOptions | RegexOptions.Singleline ), (c, s, m) => new FormattingNode(FormattingKind.Italic, Parse(c, s.Relocate(m.Groups[1]))) ); private static readonly IMatcher< MarkdownContext, MarkdownNode > ItalicBoldFormattingNodeMatcher = new RegexMatcher<MarkdownContext, MarkdownNode>( // There must be exactly three closing asterisks. new Regex(@"\*(\*\*.+?\*\*)\*(?!\*)", DefaultRegexOptions | RegexOptions.Singleline), (c, s, m) => new FormattingNode( FormattingKind.Italic, Parse(c, s.Relocate(m.Groups[1]), BoldFormattingNodeMatcher) ) ); private static readonly IMatcher<MarkdownContext, MarkdownNode> ItalicAltFormattingNodeMatcher = new RegexMatcher<MarkdownContext, MarkdownNode>( // Closing underscore must not be followed by a word character. new Regex(@"_(.+?)_(?!\w)", DefaultRegexOptions | RegexOptions.Singleline), (c, s, m) => new FormattingNode(FormattingKind.Italic, Parse(c, s.Relocate(m.Groups[1]))) ); private static readonly IMatcher<MarkdownContext, MarkdownNode> UnderlineFormattingNodeMatcher = new RegexMatcher<MarkdownContext, MarkdownNode>( // There must be exactly two closing underscores. new Regex(@"__(.+?)__(?!_)", DefaultRegexOptions | RegexOptions.Singleline), (c, s, m) => new FormattingNode(FormattingKind.Underline, Parse(c, s.Relocate(m.Groups[1]))) ); private static readonly IMatcher< MarkdownContext, MarkdownNode > ItalicUnderlineFormattingNodeMatcher = new RegexMatcher<MarkdownContext, MarkdownNode>( // There must be exactly three closing underscores. new Regex(@"_(__.+?__)_(?!_)", DefaultRegexOptions | RegexOptions.Singleline), (c, s, m) => new FormattingNode( FormattingKind.Italic, Parse(c, s.Relocate(m.Groups[1]), UnderlineFormattingNodeMatcher) ) ); private static readonly IMatcher< MarkdownContext, MarkdownNode > StrikethroughFormattingNodeMatcher = new RegexMatcher<MarkdownContext, MarkdownNode>( new Regex(@"~~(.+?)~~", DefaultRegexOptions | RegexOptions.Singleline), (c, s, m) => new FormattingNode(FormattingKind.Strikethrough, Parse(c, s.Relocate(m.Groups[1]))) ); private static readonly IMatcher<MarkdownContext, MarkdownNode> SpoilerFormattingNodeMatcher = new RegexMatcher<MarkdownContext, MarkdownNode>( new Regex(@"\|\|(.+?)\|\|", DefaultRegexOptions | RegexOptions.Singleline), (c, s, m) => new FormattingNode(FormattingKind.Spoiler, Parse(c, s.Relocate(m.Groups[1]))) ); private static readonly IMatcher<MarkdownContext, MarkdownNode> SingleLineQuoteNodeMatcher = new RegexMatcher<MarkdownContext, MarkdownNode>( // Include the linebreak in the content so that the lines are preserved in quotes. new Regex(@"^>\s(.+\n?)", DefaultRegexOptions), (c, s, m) => new FormattingNode(FormattingKind.Quote, Parse(c, s.Relocate(m.Groups[1]))) ); private static readonly IMatcher< MarkdownContext, MarkdownNode > RepeatedSingleLineQuoteNodeMatcher = new RegexMatcher<MarkdownContext, MarkdownNode>( // Include the linebreaks in the content, so that the lines are preserved in quotes. // Empty content is allowed within quotes. // https://github.com/Tyrrrz/DiscordChatExporter/issues/1115 new Regex(@"(?:^>\s(.*\n?)){2,}", DefaultRegexOptions), (c, s, m) => new FormattingNode( FormattingKind.Quote, m.Groups[1].Captures.SelectMany(r => Parse(c, s.Relocate(r))).ToArray() ) ); private static readonly IMatcher<MarkdownContext, MarkdownNode> MultiLineQuoteNodeMatcher = new RegexMatcher<MarkdownContext, MarkdownNode>( new Regex(@"^>>>\s(.+)", DefaultRegexOptions | RegexOptions.Singleline), (c, s, m) => new FormattingNode(FormattingKind.Quote, Parse(c, s.Relocate(m.Groups[1]))) ); private static readonly IMatcher<MarkdownContext, MarkdownNode> HeadingNodeMatcher = new RegexMatcher<MarkdownContext, MarkdownNode>( // Consume the linebreak so that it's not attached to following nodes. new Regex(@"^(\#{1,3})\s(.+)\n", DefaultRegexOptions), (c, s, m) => new HeadingNode(m.Groups[1].Length, Parse(c, s.Relocate(m.Groups[2]))) ); private static readonly IMatcher<MarkdownContext, MarkdownNode> ListNodeMatcher = new RegexMatcher<MarkdownContext, MarkdownNode>( // Can be preceded by whitespace, which specifies the list's nesting level. // Following lines that start with (level+1) whitespace are considered part of the list item. // Consume the linebreak so that it's not attached to following nodes. new Regex(@"^(\s*)(?:[\-\*]\s(.+(?:\n\s\1.*)*)?\n?)+", DefaultRegexOptions), (c, s, m) => new ListNode( m.Groups[2] .Captures.Select(x => new ListItemNode(Parse(c, s.Relocate(x)))) .ToArray() ) ); /* Code blocks */ private static readonly IMatcher<MarkdownContext, MarkdownNode> InlineCodeBlockNodeMatcher = new RegexMatcher<MarkdownContext, MarkdownNode>( // One or two backticks are allowed, but they must match on both sides. new Regex(@"(`{1,2})([^`]+)\1", DefaultRegexOptions | RegexOptions.Singleline), (_, _, m) => new InlineCodeBlockNode(m.Groups[2].Value) ); private static readonly IMatcher<MarkdownContext, MarkdownNode> MultiLineCodeBlockNodeMatcher = new RegexMatcher<MarkdownContext, MarkdownNode>( // Language identifier is one word immediately after opening backticks, followed immediately by a linebreak. // Blank lines at the beginning and at the end of content are trimmed. new Regex(@"\`\`\`(?:(\w*)\n)?(.+?)\`\`\`", DefaultRegexOptions | RegexOptions.Singleline), (_, _, m) => new MultiLineCodeBlockNode(m.Groups[1].Value, m.Groups[2].Value.Trim('\r', '\n')) ); /* Mentions */ private static readonly IMatcher<MarkdownContext, MarkdownNode> EveryoneMentionNodeMatcher = new StringMatcher<MarkdownContext, MarkdownNode>( "@everyone", (_, _) => new MentionNode(null, MentionKind.Everyone) ); private static readonly IMatcher<MarkdownContext, MarkdownNode> HereMentionNodeMatcher = new StringMatcher<MarkdownContext, MarkdownNode>( "@here", (_, _) => new MentionNode(null, MentionKind.Here) ); private static readonly IMatcher<MarkdownContext, MarkdownNode> UserMentionNodeMatcher = new RegexMatcher<MarkdownContext, MarkdownNode>( // Capture <@123456> or <@!123456> new Regex(@"<@!?(\d+)>", DefaultRegexOptions), (_, _, m) => new MentionNode(Snowflake.TryParse(m.Groups[1].Value), MentionKind.User) ); private static readonly IMatcher<MarkdownContext, MarkdownNode> ChannelMentionNodeMatcher = new RegexMatcher<MarkdownContext, MarkdownNode>( // Capture <#123456> new Regex(@"<\#!?(\d+)>", DefaultRegexOptions), (_, _, m) => new MentionNode(Snowflake.TryParse(m.Groups[1].Value), MentionKind.Channel) ); private static readonly IMatcher<MarkdownContext, MarkdownNode> RoleMentionNodeMatcher = new RegexMatcher<MarkdownContext, MarkdownNode>( // Capture <@&123456> new Regex(@"<@&(\d+)>", DefaultRegexOptions), (_, _, m) => new MentionNode(Snowflake.TryParse(m.Groups[1].Value), MentionKind.Role) ); /* Emoji */ private static readonly IMatcher<MarkdownContext, MarkdownNode> StandardEmojiNodeMatcher = new RegexMatcher<MarkdownContext, MarkdownNode>( new Regex( @"(" + // Country flag emoji (two regional indicator surrogate pairs) @"(?:\uD83C[\uDDE6-\uDDFF]){2}|" + // Digit emoji (digit followed by enclosing mark) @"\d\p{Me}|" + // Surrogate pair @"\p{Cs}{2}|" + // Miscellaneous characters @"[" + @"\u2600-\u2604" + @"\u260E\u2611" + @"\u2614-\u2615" + @"\u2618\u261D\u2620" + @"\u2622-\u2623" + @"\u2626\u262A" + @"\u262E-\u262F" + @"\u2638-\u263A" + @"\u2640\u2642" + @"\u2648-\u2653" + @"\u265F-\u2660" + @"\u2663" + @"\u2665-\u2666" + @"\u2668\u267B" + @"\u267E-\u267F" + @"\u2692-\u2697" + @"\u2699" + @"\u269B-\u269C" + @"\u26A0-\u26A1" + @"\u26A7" + @"\u26AA-\u26AB" + @"\u26B0-\u26B1" + @"\u26BD-\u26BE" + @"\u26C4-\u26C5" + @"\u26C8" + @"\u26CE-\u26CF" + @"\u26D1" + @"\u26D3-\u26D4" + @"\u26E9-\u26EA" + @"\u26F0-\u26F5" + @"\u26F7-\u26FA" + @"\u26FD" + @"]" + @")", DefaultRegexOptions ), (_, _, m) => new EmojiNode(m.Groups[1].Value) ); private static readonly IMatcher<MarkdownContext, MarkdownNode> CodedStandardEmojiNodeMatcher = new RegexMatcher<MarkdownContext, MarkdownNode>( // Capture :thinking: new Regex(@":([\w_]+):", DefaultRegexOptions), (_, _, m) => EmojiIndex.TryGetName(m.Groups[1].Value)?.Pipe(n => new EmojiNode(n)) ); private static readonly IMatcher<MarkdownContext, MarkdownNode> CustomEmojiNodeMatcher = new RegexMatcher<MarkdownContext, MarkdownNode>( // Capture <:lul:123456> or <a:lul:123456> new Regex(@"<(a)?:(.+?):(\d+?)>", DefaultRegexOptions), (_, _, m) => new EmojiNode( Snowflake.TryParse(m.Groups[3].Value), m.Groups[2].Value, !string.IsNullOrWhiteSpace(m.Groups[1].Value) ) ); /* Links */ private static readonly IMatcher<MarkdownContext, MarkdownNode> AutoLinkNodeMatcher = new RegexMatcher<MarkdownContext, MarkdownNode>( // Any non-whitespace character after http:// or https:// // until the last punctuation character or whitespace. new Regex(@"(https?://\S*[^\.,:;""'\s])", DefaultRegexOptions), (_, _, m) => new LinkNode(m.Groups[1].Value) ); private static readonly IMatcher<MarkdownContext, MarkdownNode> HiddenLinkNodeMatcher = new RegexMatcher<MarkdownContext, MarkdownNode>( // Same as auto link but also surrounded by angular brackets new Regex(@"<(https?://\S*[^\.,:;""'\s])>", DefaultRegexOptions), (_, _, m) => new LinkNode(m.Groups[1].Value) ); private static readonly IMatcher<MarkdownContext, MarkdownNode> MaskedLinkNodeMatcher = new RegexMatcher<MarkdownContext, MarkdownNode>( // Capture [title](link) new Regex(@"\[(.+?)\]\((.+?)\)", DefaultRegexOptions), (c, s, m) => new LinkNode(m.Groups[2].Value, Parse(c, s.Relocate(m.Groups[1]))) ); /* Text */ private static readonly IMatcher<MarkdownContext, MarkdownNode> ShrugTextNodeMatcher = new StringMatcher<MarkdownContext, MarkdownNode>( // Capture the shrug kaomoji. // This escapes it from matching for formatting. @"¯\_(ツ)_/¯", (s, _) => new TextNode(s.ToString()) ); private static readonly IMatcher<MarkdownContext, MarkdownNode> IgnoredEmojiTextNodeMatcher = new RegexMatcher<MarkdownContext, MarkdownNode>( // Capture some specific emoji that don't get rendered. // This escapes them from matching for emoji. new Regex(@"([\u26A7\u2640\u2642\u2695\u267E\u00A9\u00AE\u2122])", DefaultRegexOptions), (_, _, m) => new TextNode(m.Groups[1].Value) ); private static readonly IMatcher<MarkdownContext, MarkdownNode> EscapedSymbolTextNodeMatcher = new RegexMatcher<MarkdownContext, MarkdownNode>( // Capture any "symbol/other" character or surrogate pair preceded by a backslash. // This escapes them from matching for emoji. // https://github.com/Tyrrrz/DiscordChatExporter/issues/230 new Regex(@"\\(\p{So}|\p{Cs}{2})", DefaultRegexOptions), (_, _, m) => new TextNode(m.Groups[1].Value) ); private static readonly IMatcher< MarkdownContext, MarkdownNode > EscapedCharacterTextNodeMatcher = new RegexMatcher<MarkdownContext, MarkdownNode>( // Capture any non-whitespace, non latin alphanumeric character preceded by a backslash. // This escapes them from matching for formatting or other tokens. new Regex(@"\\([^a-zA-Z0-9\s])", DefaultRegexOptions), (_, _, m) => new TextNode(m.Groups[1].Value) ); /* Misc */ private static readonly IMatcher<MarkdownContext, MarkdownNode> TimestampNodeMatcher = new RegexMatcher<MarkdownContext, MarkdownNode>( // Capture <t:12345678> or <t:12345678:R> new Regex(@"<t:(-?\d+)(?::(\w))?>", DefaultRegexOptions), (_, _, m) => { try { var instant = DateTimeOffset.UnixEpoch + TimeSpan.FromSeconds( long.Parse( m.Groups[1].Value, NumberStyles.Integer, CultureInfo.InvariantCulture ) ); // https://discord.com/developers/docs/reference#message-formatting-timestamp-styles var format = m.Groups[2].Value.NullIfWhiteSpace() switch { // Known formats "t" => "t", "T" => "T", "d" => "d", "D" => "D", "f" => "f", "F" => "F", // Relative format: ignore because it doesn't make sense in a static export "r" => null, "R" => null, // Unspecified format: will be mapped to the default format null => null, // Unknown format: throw an exception to consider this timestamp invalid // https://github.com/Tyrrrz/DiscordChatExporter/issues/1156 var f => throw new InvalidOperationException( $"Unknown timestamp format '{f}'." ), }; return new TimestampNode(instant, format); } // https://github.com/Tyrrrz/DiscordChatExporter/issues/681 // https://github.com/Tyrrrz/DiscordChatExporter/issues/766 catch (Exception ex) when (ex is FormatException or ArgumentOutOfRangeException or OverflowException or InvalidOperationException ) { // For invalid timestamps, Discord renders "Invalid Date" instead of ignoring the markdown return TimestampNode.Invalid; } } ); // Matchers that have similar patterns are ordered from most specific to least specific private static readonly IMatcher<MarkdownContext, MarkdownNode> NodeMatcher = new AggregateMatcher<MarkdownContext, MarkdownNode>( // Escaped text ShrugTextNodeMatcher, IgnoredEmojiTextNodeMatcher, EscapedSymbolTextNodeMatcher, EscapedCharacterTextNodeMatcher, // Formatting ItalicBoldFormattingNodeMatcher, ItalicUnderlineFormattingNodeMatcher, BoldFormattingNodeMatcher, ItalicFormattingNodeMatcher, UnderlineFormattingNodeMatcher, ItalicAltFormattingNodeMatcher, StrikethroughFormattingNodeMatcher, SpoilerFormattingNodeMatcher, MultiLineQuoteNodeMatcher, RepeatedSingleLineQuoteNodeMatcher, SingleLineQuoteNodeMatcher, HeadingNodeMatcher, ListNodeMatcher, // Code blocks MultiLineCodeBlockNodeMatcher, InlineCodeBlockNodeMatcher, // Mentions EveryoneMentionNodeMatcher, HereMentionNodeMatcher, UserMentionNodeMatcher, ChannelMentionNodeMatcher, RoleMentionNodeMatcher, // Links MaskedLinkNodeMatcher, AutoLinkNodeMatcher, HiddenLinkNodeMatcher, // Emoji StandardEmojiNodeMatcher, CustomEmojiNodeMatcher, CodedStandardEmojiNodeMatcher, // Misc TimestampNodeMatcher ); // Minimal set of matchers for non-multimedia formats (e.g. plain text) private static readonly IMatcher<MarkdownContext, MarkdownNode> MinimalNodeMatcher = new AggregateMatcher<MarkdownContext, MarkdownNode>( // Mentions EveryoneMentionNodeMatcher, HereMentionNodeMatcher, UserMentionNodeMatcher, ChannelMentionNodeMatcher, RoleMentionNodeMatcher, // Emoji CustomEmojiNodeMatcher, // Misc TimestampNodeMatcher ); private static IReadOnlyList<MarkdownNode> Parse( MarkdownContext context, StringSegment segment, IMatcher<MarkdownContext, MarkdownNode> matcher ) { // Limit recursion depth to a reasonable number to prevent // stack overflow on messages with inadvertently deep nesting. // Example: ********************************* (repeat ad nauseam) // https://github.com/Tyrrrz/DiscordChatExporter/issues/1214 if (context.Depth >= 32) return [new TextNode(segment.ToString())]; return matcher .MatchAll( new MarkdownContext(context.Depth + 1), segment, (_, s) => new TextNode(s.ToString()) ) .Select(r => r.Value) .ToArray(); } } internal static partial class MarkdownParser { private static IReadOnlyList<MarkdownNode> Parse( MarkdownContext context, StringSegment segment ) => Parse(context, segment, NodeMatcher); public static IReadOnlyList<MarkdownNode> Parse(string markdown) => Parse(new MarkdownContext(), new StringSegment(markdown)); private static IReadOnlyList<MarkdownNode> ParseMinimal( MarkdownContext context, StringSegment segment ) => Parse(context, segment, MinimalNodeMatcher); public static IReadOnlyList<MarkdownNode> ParseMinimal(string markdown) => ParseMinimal(new MarkdownContext(), new StringSegment(markdown)); private static void ExtractLinks(IEnumerable<MarkdownNode> nodes, ICollection<LinkNode> links) { foreach (var node in nodes) { if (node is LinkNode linkNode) links.Add(linkNode); if (node is IContainerNode containerNode) ExtractLinks(containerNode.Children, links); } } public static IReadOnlyList<LinkNode> ExtractLinks(string markdown) { var links = new List<LinkNode>(); ExtractLinks(Parse(markdown), links); return links; } }
```

# Markdown/Parsing/MarkdownVisitor.cs

```cs
using System; using System.Collections.Generic; using System.Threading; using System.Threading.Tasks; namespace DiscordChatExporter.Core.Markdown.Parsing; internal abstract class MarkdownVisitor { protected virtual ValueTask VisitTextAsync( TextNode text, CancellationToken cancellationToken = default ) => default; protected virtual async ValueTask VisitFormattingAsync( FormattingNode formatting, CancellationToken cancellationToken = default ) => await VisitAsync(formatting.Children, cancellationToken); protected virtual async ValueTask VisitHeadingAsync( HeadingNode heading, CancellationToken cancellationToken = default ) => await VisitAsync(heading.Children, cancellationToken); protected virtual async ValueTask VisitListAsync( ListNode list, CancellationToken cancellationToken = default ) => await VisitAsync(list.Items, cancellationToken); protected virtual async ValueTask VisitListItemAsync( ListItemNode listItem, CancellationToken cancellationToken = default ) => await VisitAsync(listItem.Children, cancellationToken); protected virtual ValueTask VisitInlineCodeBlockAsync( InlineCodeBlockNode inlineCodeBlock, CancellationToken cancellationToken = default ) => default; protected virtual ValueTask VisitMultiLineCodeBlockAsync( MultiLineCodeBlockNode multiLineCodeBlock, CancellationToken cancellationToken = default ) => default; protected virtual async ValueTask VisitLinkAsync( LinkNode link, CancellationToken cancellationToken = default ) => await VisitAsync(link.Children, cancellationToken); protected virtual ValueTask VisitEmojiAsync( EmojiNode emoji, CancellationToken cancellationToken = default ) => default; protected virtual ValueTask VisitMentionAsync( MentionNode mention, CancellationToken cancellationToken = default ) => default; protected virtual ValueTask VisitTimestampAsync( TimestampNode timestamp, CancellationToken cancellationToken = default ) => default; public async ValueTask VisitAsync( MarkdownNode node, CancellationToken cancellationToken = default ) { if (node is TextNode text) { await VisitTextAsync(text, cancellationToken); return; } if (node is FormattingNode formatting) { await VisitFormattingAsync(formatting, cancellationToken); return; } if (node is HeadingNode heading) { await VisitHeadingAsync(heading, cancellationToken); return; } if (node is ListNode list) { await VisitListAsync(list, cancellationToken); return; } if (node is ListItemNode listItem) { await VisitListItemAsync(listItem, cancellationToken); return; } if (node is InlineCodeBlockNode inlineCodeBlock) { await VisitInlineCodeBlockAsync(inlineCodeBlock, cancellationToken); return; } if (node is MultiLineCodeBlockNode multiLineCodeBlock) { await VisitMultiLineCodeBlockAsync(multiLineCodeBlock, cancellationToken); return; } if (node is LinkNode link) { await VisitLinkAsync(link, cancellationToken); return; } if (node is EmojiNode emoji) { await VisitEmojiAsync(emoji, cancellationToken); return; } if (node is MentionNode mention) { await VisitMentionAsync(mention, cancellationToken); return; } if (node is TimestampNode timestamp) { await VisitTimestampAsync(timestamp, cancellationToken); return; } throw new ArgumentOutOfRangeException(nameof(node)); } public async ValueTask VisitAsync( IEnumerable<MarkdownNode> nodes, CancellationToken cancellationToken = default ) { foreach (var node in nodes) await VisitAsync(node, cancellationToken); } }
```

# Markdown/Parsing/ParsedMatch.cs

```cs
namespace DiscordChatExporter.Core.Markdown.Parsing; internal class ParsedMatch<T>(StringSegment segment, T value) { public StringSegment Segment { get; } = segment; public T Value { get; } = value; }
```

# Markdown/Parsing/RegexMatcher.cs

```cs
using System; using System.Text.RegularExpressions; namespace DiscordChatExporter.Core.Markdown.Parsing; internal class RegexMatcher<TContext, TValue>( Regex regex, Func<TContext, StringSegment, Match, TValue?> transform ) : IMatcher<TContext, TValue> { public ParsedMatch<TValue>? TryMatch(TContext context, StringSegment segment) { var match = regex.Match(segment.Source, segment.StartIndex, segment.Length); if (!match.Success) return null; // Overload regex.Match(string, int, int) doesn't take the whole string into account, // it effectively functions as a match check on a substring. // Which is super weird because regex.Match(string, int) takes the whole input in context. // So in order to properly account for ^/$ regex tokens, we need to make sure that // the expression also matches on the bigger part of the input. if (!regex.IsMatch(segment.Source[..segment.EndIndex], segment.StartIndex)) return null; var segmentMatch = segment.Relocate(match); var value = transform(context, segmentMatch, match); return value is not null ? new ParsedMatch<TValue>(segmentMatch, value) : null; } }
```

# Markdown/Parsing/StringMatcher.cs

```cs
using System; namespace DiscordChatExporter.Core.Markdown.Parsing; internal class StringMatcher<TContext, TValue>( string needle, StringComparison comparison, Func<TContext, StringSegment, TValue?> transform ) : IMatcher<TContext, TValue> { public StringMatcher(string needle, Func<TContext, StringSegment, TValue> transform) : this(needle, StringComparison.Ordinal, transform) { } public ParsedMatch<TValue>? TryMatch(TContext context, StringSegment segment) { var index = segment.Source.IndexOf(needle, segment.StartIndex, segment.Length, comparison); if (index < 0) return null; var segmentMatch = segment.Relocate(index, needle.Length); var value = transform(context, segmentMatch); return value is not null ? new ParsedMatch<TValue>(segmentMatch, value) : null; } }
```

# Markdown/Parsing/StringSegment.cs

```cs
using System.Text.RegularExpressions; namespace DiscordChatExporter.Core.Markdown.Parsing; internal readonly record struct StringSegment(string Source, int StartIndex, int Length) { public int EndIndex => StartIndex + Length; public StringSegment(string target) : this(target, 0, target.Length) { } public StringSegment Relocate(int newStartIndex, int newLength) => new(Source, newStartIndex, newLength); public StringSegment Relocate(Capture capture) => Relocate(capture.Index, capture.Length); public override string ToString() => Source.Substring(StartIndex, Length); }
```

# Markdown/TextNode.cs

```cs
namespace DiscordChatExporter.Core.Markdown; internal record TextNode(string Text) : MarkdownNode;
```

# Markdown/TimestampNode.cs

```cs
using System; namespace DiscordChatExporter.Core.Markdown; // Null date means invalid timestamp internal record TimestampNode(DateTimeOffset? Instant, string? Format) : MarkdownNode { public static TimestampNode Invalid { get; } = new(null, null); }
```

# Utils/Docker.cs

```cs
using System; namespace DiscordChatExporter.Core.Utils; public static class Docker { public static bool IsRunningInContainer { get; } = Environment.GetEnvironmentVariable("DOTNET_RUNNING_IN_CONTAINER") == "true"; }
```

# Utils/Extensions/AsyncCollectionExtensions.cs

```cs
using System.Collections.Generic; using System.Runtime.CompilerServices; using System.Threading.Tasks; namespace DiscordChatExporter.Core.Utils.Extensions; public static class AsyncCollectionExtensions { private static async ValueTask<IReadOnlyList<T>> CollectAsync<T>( this IAsyncEnumerable<T> asyncEnumerable ) { var list = new List<T>(); await foreach (var i in asyncEnumerable) list.Add(i); return list; } public static ValueTaskAwaiter<IReadOnlyList<T>> GetAwaiter<T>( this IAsyncEnumerable<T> asyncEnumerable ) => asyncEnumerable.CollectAsync().GetAwaiter(); }
```

# Utils/Extensions/BinaryExtensions.cs

```cs
using System.Globalization; using System.Text; namespace DiscordChatExporter.Core.Utils.Extensions; public static class BinaryExtensions { public static string ToHex(this byte[] data, bool isUpperCase = true) { var buffer = new StringBuilder(2 * data.Length); foreach (var b in data) { buffer.Append(b.ToString(isUpperCase ? "X2" : "x2", CultureInfo.InvariantCulture)); } return buffer.ToString(); } }
```

# Utils/Extensions/CollectionExtensions.cs

```cs
using System.Collections.Generic; namespace DiscordChatExporter.Core.Utils.Extensions; public static class CollectionExtensions { public static IEnumerable<T> ToSingletonEnumerable<T>(this T obj) { yield return obj; } public static IEnumerable<(T value, int index)> WithIndex<T>(this IEnumerable<T> source) { var i = 0; foreach (var o in source) yield return (o, i++); } public static IEnumerable<T> WhereNotNull<T>(this IEnumerable<T?> source) where T : class { foreach (var o in source) { if (o is not null) yield return o; } } }
```

# Utils/Extensions/ColorExtensions.cs

```cs
using System.Drawing; namespace DiscordChatExporter.Core.Utils.Extensions; public static class ColorExtensions { public static Color WithAlpha(this Color color, int alpha) => Color.FromArgb(alpha, color); public static Color ResetAlpha(this Color color) => color.WithAlpha(255); public static int ToRgb(this Color color) => color.ToArgb() & 0xffffff; public static string ToHex(this Color color) => $"#{color.R:X2}{color.G:X2}{color.B:X2}"; }
```

# Utils/Extensions/ExceptionExtensions.cs

```cs
using System; using System.Collections.Generic; namespace DiscordChatExporter.Core.Utils.Extensions; public static class ExceptionExtensions { private static void PopulateChildren(this Exception exception, ICollection<Exception> children) { if (exception is AggregateException aggregateException) { foreach (var innerException in aggregateException.InnerExceptions) { children.Add(innerException); PopulateChildren(innerException, children); } } else if (exception.InnerException is not null) { children.Add(exception.InnerException); PopulateChildren(exception.InnerException, children); } } public static IReadOnlyList<Exception> GetSelfAndChildren(this Exception exception) { var children = new List<Exception> { exception }; PopulateChildren(exception, children); return children; } }
```

# Utils/Extensions/GenericExtensions.cs

```cs
using System; using System.Collections.Generic; namespace DiscordChatExporter.Core.Utils.Extensions; public static class GenericExtensions { public static TOut Pipe<TIn, TOut>(this TIn input, Func<TIn, TOut> transform) => transform(input); public static T? NullIf<T>(this T value, Func<T, bool> predicate) where T : struct => !predicate(value) ? value : null; public static T? NullIfDefault<T>(this T value) where T : struct => value.NullIf(v => EqualityComparer<T>.Default.Equals(v, default)); }
```

# Utils/Extensions/HttpExtensions.cs

```cs
using System.Net.Http.Headers; namespace DiscordChatExporter.Core.Utils.Extensions; public static class HttpExtensions { public static string? TryGetValue(this HttpHeaders headers, string name) => headers.TryGetValues(name, out var values) ? string.Concat(values) : null; }
```

# Utils/Extensions/StringExtensions.cs

```cs
using System; using System.Text; namespace DiscordChatExporter.Core.Utils.Extensions; public static class StringExtensions { public static string? NullIfWhiteSpace(this string str) => !string.IsNullOrWhiteSpace(str) ? str : null; public static string Truncate(this string str, int charCount) => str.Length > charCount ? str[..charCount] : str; public static string ToSpaceSeparatedWords(this string str) { var builder = new StringBuilder(str.Length * 2); foreach (var c in str) { if (char.IsUpper(c) && builder.Length > 0) builder.Append(' '); builder.Append(c); } return builder.ToString(); } public static T? ParseEnumOrNull<T>(this string str, bool ignoreCase = true) where T : struct, Enum => Enum.TryParse<T>(str, ignoreCase, out var result) ? result : null; public static StringBuilder AppendIfNotEmpty(this StringBuilder builder, char value) => builder.Length > 0 ? builder.Append(value) : builder; }
```

# Utils/Extensions/SuperpowerExtensions.cs

```cs
using System; using System.Diagnostics.CodeAnalysis; using Superpower; using Superpower.Parsers; namespace DiscordChatExporter.Core.Utils.Extensions; public static class SuperpowerExtensions { public static TextParser<string> Text(this TextParser<char[]> parser) => parser.Select(chars => new string(chars)); public static TextParser<T> Token<T>(this TextParser<T> parser) => parser.Between(Character.WhiteSpace.IgnoreMany(), Character.WhiteSpace.IgnoreMany()); // Only used for debugging while writing Superpower parsers. // From https://twitter.com/nblumhardt/status/1389349059786264578 [ExcludeFromCodeCoverage] public static TextParser<T> Log<T>(this TextParser<T> parser, string description) => i => { Console.WriteLine($"Trying {description} ->"); var r = parser(i); Console.WriteLine($"Result was {r}"); return r; }; }
```

# Utils/Extensions/TimeSpanExtensions.cs

```cs
using System; namespace DiscordChatExporter.Core.Utils.Extensions; public static class TimeSpanExtensions { public static TimeSpan Clamp(this TimeSpan value, TimeSpan min, TimeSpan max) { if (value < min) return min; if (value > max) return max; return value; } }
```

# Utils/Http.cs

```cs
using System; using System.Linq; using System.Net; using System.Net.Http; using System.Net.Sockets; using System.Security.Authentication; using System.Threading.Tasks; using DiscordChatExporter.Core.Utils.Extensions; using Polly; using Polly.Retry; namespace DiscordChatExporter.Core.Utils; public static class Http { public static HttpClient Client { get; } = new(); private static bool IsRetryableStatusCode(HttpStatusCode statusCode) => statusCode is HttpStatusCode.TooManyRequests or HttpStatusCode.RequestTimeout || // Treat all server-side errors as retryable // https://github.com/Tyrrrz/DiscordChatExporter/issues/908 (int)statusCode >= 500; private static bool IsRetryableException(Exception exception) => exception .GetSelfAndChildren() .Any(ex => ex is TimeoutException or SocketException or AuthenticationException || ex is HttpRequestException hrex && IsRetryableStatusCode(hrex.StatusCode ?? HttpStatusCode.OK) ); public static ResiliencePipeline ResiliencePipeline { get; } = new ResiliencePipelineBuilder() .AddRetry( new RetryStrategyOptions { ShouldHandle = new PredicateBuilder().Handle<Exception>(IsRetryableException), MaxRetryAttempts = 4, BackoffType = DelayBackoffType.Exponential, Delay = TimeSpan.FromSeconds(1), } ) .Build(); public static ResiliencePipeline<HttpResponseMessage> ResponseResiliencePipeline { get; } = new ResiliencePipelineBuilder<HttpResponseMessage>() .AddRetry( new RetryStrategyOptions<HttpResponseMessage> { ShouldHandle = new PredicateBuilder<HttpResponseMessage>() .Handle<Exception>(IsRetryableException) .HandleResult(m => IsRetryableStatusCode(m.StatusCode)), MaxRetryAttempts = 8, DelayGenerator = args => { // If rate-limited, use retry-after header as the guide. // The response can be null here if an exception was thrown. if (args.Outcome.Result?.Headers.RetryAfter?.Delta is { } retryAfter) { // Add some buffer just in case return ValueTask.FromResult<TimeSpan?>( retryAfter + TimeSpan.FromSeconds(1) ); } return ValueTask.FromResult<TimeSpan?>( TimeSpan.FromSeconds(Math.Pow(2, args.AttemptNumber) + 1) ); }, } ) .Build(); }
```

# Utils/PathEx.cs

```cs
using System; using System.Collections.Generic; using System.IO; using System.Text; namespace DiscordChatExporter.Core.Utils; public static class PathEx { private static readonly HashSet<char> InvalidFileNameChars = [ .. Path.GetInvalidFileNameChars(), ]; public static string EscapeFileName(string path) { var buffer = new StringBuilder(path.Length); foreach (var c in path) buffer.Append(!InvalidFileNameChars.Contains(c) ? c : '_'); // File names cannot end with a dot on Windows // https://github.com/Tyrrrz/DiscordChatExporter/issues/977 if (OperatingSystem.IsWindows()) { while (buffer.Length > 0 && buffer[^1] == '.') buffer.Remove(buffer.Length - 1, 1); } return buffer.ToString(); } }
```

# Utils/UrlBuilder.cs

```cs
using System; using System.Collections.Generic; using System.Linq; using System.Net; using System.Text; namespace DiscordChatExporter.Core.Utils; public class UrlBuilder { private string _path = ""; private readonly Dictionary<string, string?> _queryParameters = new(StringComparer.OrdinalIgnoreCase); public UrlBuilder SetPath(string path) { _path = path; return this; } public UrlBuilder SetQueryParameter(string key, string? value, bool ignoreUnsetValue = true) { if (ignoreUnsetValue && string.IsNullOrWhiteSpace(value)) return this; var keyEncoded = WebUtility.UrlEncode(key); var valueEncoded = WebUtility.UrlEncode(value); _queryParameters[keyEncoded] = valueEncoded; return this; } public string Build() { var buffer = new StringBuilder(); buffer.Append(_path); if (_queryParameters.Any()) buffer .Append('?') .AppendJoin('&', _queryParameters.Select(kvp => $"{kvp.Key}={kvp.Value}")); return buffer.ToString(); } }
```

