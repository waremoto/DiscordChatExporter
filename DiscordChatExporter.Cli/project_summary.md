# Commands/Base/DiscordCommandBase.cs

```cs
using System; using System.Threading.Tasks; using CliFx; using CliFx.Attributes; using CliFx.Infrastructure; using DiscordChatExporter.Core.Discord; using DiscordChatExporter.Core.Utils; namespace DiscordChatExporter.Cli.Commands.Base; public abstract class DiscordCommandBase : ICommand { [CommandOption( "token", 't', EnvironmentVariable = "DISCORD_TOKEN", Description = "Authentication token." )] public required string Token { get; init; } [Obsolete("This option doesn't do anything. Kept for backwards compatibility.")] [CommandOption( "bot", 'b', EnvironmentVariable = "DISCORD_TOKEN_BOT", Description = "This option doesn't do anything. Kept for backwards compatibility." )] public bool IsBotToken { get; init; } = false; private DiscordClient? _discordClient; protected DiscordClient Discord => _discordClient ??= new DiscordClient(Token); public virtual ValueTask ExecuteAsync(IConsole console) { #pragma warning disable CS0618 // Warn if the bot option is used if (IsBotToken) { using (console.WithForegroundColor(ConsoleColor.DarkYellow)) { console.Error.WriteLine( "Warning: The --bot option is deprecated and should not be used. " + "The token type is now inferred automatically. " + "Please update your workflows as this option may be completely removed in a future version." ); } } #pragma warning restore CS0618 // Note about interactivity for Docker if (console.IsOutputRedirected && Docker.IsRunningInContainer) { console.Error.WriteLine( "Note: Output streams are redirected, rich console interactions are disabled. " + "If you are running this command in Docker, consider allocating a pseudo-terminal for better user experience (docker run -it ...)." ); } return default; } }
```

# Commands/Base/ExportCommandBase.cs

```cs
using System; using System.Collections.Concurrent; using System.Collections.Generic; using System.IO; using System.Linq; using System.Threading.Tasks; using CliFx.Attributes; using CliFx.Exceptions; using CliFx.Infrastructure; using DiscordChatExporter.Cli.Commands.Converters; using DiscordChatExporter.Cli.Utils.Extensions; using DiscordChatExporter.Core.Discord; using DiscordChatExporter.Core.Discord.Data; using DiscordChatExporter.Core.Exceptions; using DiscordChatExporter.Core.Exporting; using DiscordChatExporter.Core.Exporting.Filtering; using DiscordChatExporter.Core.Exporting.Partitioning; using DiscordChatExporter.Core.Utils.Extensions; using Gress; using Spectre.Console; namespace DiscordChatExporter.Cli.Commands.Base; public abstract class ExportCommandBase : DiscordCommandBase { private readonly string _outputPath = Directory.GetCurrentDirectory(); [CommandOption( "output", 'o', Description = "Output file or directory path. " + "If a directory is specified, file names will be generated automatically based on the channel names and export parameters. " + "Directory paths must end with a slash to avoid ambiguity. " + "Supports template tokens, see the documentation for more info." )] public string OutputPath { get => _outputPath; // Handle ~/ in paths on Unix systems // https://github.com/Tyrrrz/DiscordChatExporter/pull/903 init => _outputPath = Path.GetFullPath(value); } [CommandOption("format", 'f', Description = "Export format.")] public ExportFormat ExportFormat { get; init; } = ExportFormat.HtmlDark; [CommandOption( "after", Description = "Only include messages sent after this date or message ID." )] public Snowflake? After { get; init; } [CommandOption( "before", Description = "Only include messages sent before this date or message ID." )] public Snowflake? Before { get; init; } [CommandOption( "partition", 'p', Description = "Split the output into partitions, each limited to the specified " + "number of messages (e.g. '100') or file size (e.g. '10mb')." )] public PartitionLimit PartitionLimit { get; init; } = PartitionLimit.Null; [CommandOption( "filter", Description = "Only include messages that satisfy this filter. " + "See the documentation for more info." )] public MessageFilter MessageFilter { get; init; } = MessageFilter.Null; [CommandOption( "parallel", Description = "Limits how many channels can be exported in parallel." )] public int ParallelLimit { get; init; } = 1; [CommandOption( "markdown", Description = "Process markdown, mentions, and other special tokens." )] public bool ShouldFormatMarkdown { get; init; } = true; [CommandOption( "media", Description = "Download assets referenced by the export (user avatars, attached files, embedded images, etc.)." )] public bool ShouldDownloadAssets { get; init; } [CommandOption( "reuse-media", Description = "Reuse previously downloaded assets to avoid redundant requests." )] public bool ShouldReuseAssets { get; init; } = false; private readonly string? _assetsDirPath; [CommandOption( "media-dir", Description = "Download assets to this directory. " + "If not specified, the asset directory path will be derived from the output path." )] public string? AssetsDirPath { get => _assetsDirPath; // Handle ~/ in paths on Unix systems // https://github.com/Tyrrrz/DiscordChatExporter/pull/903 init => _assetsDirPath = value is not null ? Path.GetFullPath(value) : null; } [Obsolete("This option doesn't do anything. Kept for backwards compatibility.")] [CommandOption( "dateformat", Description = "This option doesn't do anything. Kept for backwards compatibility." )] public string DateFormat { get; init; } = "MM/dd/yyyy h:mm tt"; [CommandOption( "locale", Description = "Locale to use when formatting dates and numbers. " + "If not specified, the default system locale will be used." )] public string? Locale { get; init; } [CommandOption("utc", Description = "Normalize all timestamps to UTC+0.")] public bool IsUtcNormalizationEnabled { get; init; } = false; [CommandOption( "fuck-russia", EnvironmentVariable = "FUCK_RUSSIA", Description = "Don't print the Support Ukraine message to the console.", // Use a converter to accept '1' as 'true' to reuse the existing environment variable Converter = typeof(TruthyBooleanBindingConverter) )] public bool IsUkraineSupportMessageDisabled { get; init; } = false; private ChannelExporter? _channelExporter; protected ChannelExporter Exporter => _channelExporter ??= new ChannelExporter(Discord); protected async ValueTask ExportAsync(IConsole console, IReadOnlyList<Channel> channels) { // Asset reuse can only be enabled if the download assets option is set // https://github.com/Tyrrrz/DiscordChatExporter/issues/425 if (ShouldReuseAssets && !ShouldDownloadAssets) { throw new CommandException("Option --reuse-media cannot be used without --media."); } // Assets directory can only be specified if the download assets option is set if (!string.IsNullOrWhiteSpace(AssetsDirPath) && !ShouldDownloadAssets) { throw new CommandException("Option --media-dir cannot be used without --media."); } // Make sure the user does not try to export multiple channels into one file. // Output path must either be a directory or contain template tokens for this to work. // https://github.com/Tyrrrz/DiscordChatExporter/issues/799 // https://github.com/Tyrrrz/DiscordChatExporter/issues/917 var isValidOutputPath = // Anything is valid when exporting a single channel channels.Count <= 1 // When using template tokens, assume the user knows what they're doing || OutputPath.Contains('%') // Otherwise, require an existing directory or an unambiguous directory path || Directory.Exists(OutputPath) || Path.EndsInDirectorySeparator(OutputPath); if (!isValidOutputPath) { throw new CommandException( "Attempted to export multiple channels, but the output path is neither a directory nor a template. " + "If the provided output path is meant to be treated as a directory, make sure it ends with a slash. " + $"Provided output path: '{OutputPath}'." ); } // Export var cancellationToken = console.RegisterCancellationHandler(); var errorsByChannel = new ConcurrentDictionary<Channel, string>(); await console.Output.WriteLineAsync($"Exporting {channels.Count} channel(s)..."); await console .CreateProgressTicker() .HideCompleted( // When exporting multiple channels in parallel, hide the completed tasks // because it gets hard to visually parse them as they complete out of order. // https://github.com/Tyrrrz/DiscordChatExporter/issues/1124 ParallelLimit > 1 ) .StartAsync(async ctx => { await Parallel.ForEachAsync( channels, new ParallelOptions { MaxDegreeOfParallelism = Math.Max(1, ParallelLimit), CancellationToken = cancellationToken, }, async (channel, innerCancellationToken) => { try { await ctx.StartTaskAsync( Markup.Escape(channel.GetHierarchicalName()), async progress => { var guild = await Discord.GetGuildAsync( channel.GuildId, innerCancellationToken ); var request = new ExportRequest( guild, channel, OutputPath, AssetsDirPath, ExportFormat, After, Before, PartitionLimit, MessageFilter, ShouldFormatMarkdown, ShouldDownloadAssets, ShouldReuseAssets, Locale, IsUtcNormalizationEnabled ); await Exporter.ExportChannelAsync( request, progress.ToPercentageBased(), innerCancellationToken ); } ); } catch (DiscordChatExporterException ex) when (!ex.IsFatal) { errorsByChannel[channel] = ex.Message; } } ); }); // Print the result using (console.WithForegroundColor(ConsoleColor.White)) { await console.Output.WriteLineAsync( $"Successfully exported {channels.Count - errorsByChannel.Count} channel(s)." ); } // Print errors if (errorsByChannel.Any()) { await console.Output.WriteLineAsync(); using (console.WithForegroundColor(ConsoleColor.Red)) { await console.Error.WriteLineAsync( $"Failed to export {errorsByChannel.Count} the following channel(s):" ); } foreach (var (channel, error) in errorsByChannel) { await console.Error.WriteAsync($"{channel.GetHierarchicalName()}: "); using (console.WithForegroundColor(ConsoleColor.Red)) await console.Error.WriteLineAsync(error); } await console.Error.WriteLineAsync(); } // Fail the command only if ALL channels failed to export. // If only some channels failed to export, it's okay. if (errorsByChannel.Count >= channels.Count) throw new CommandException("Export failed."); } protected async ValueTask ExportAsync(IConsole console, IReadOnlyList<Snowflake> channelIds) { var cancellationToken = console.RegisterCancellationHandler(); await console.Output.WriteLineAsync("Resolving channel(s)..."); var channels = new List<Channel>(); var channelsByGuild = new Dictionary<Snowflake, IReadOnlyList<Channel>>(); foreach (var channelId in channelIds) { var channel = await Discord.GetChannelAsync(channelId, cancellationToken); // Unwrap categories if (channel.IsCategory) { var guildChannels = channelsByGuild.GetValueOrDefault(channel.GuildId) ?? await Discord.GetGuildChannelsAsync(channel.GuildId, cancellationToken); foreach (var guildChannel in guildChannels) { if (guildChannel.Parent?.Id == channel.Id) channels.Add(guildChannel); } // Cache the guild channels to avoid redundant work channelsByGuild[channel.GuildId] = guildChannels; } else { channels.Add(channel); } } await ExportAsync(console, channels); } public override async ValueTask ExecuteAsync(IConsole console) { // Support Ukraine callout if (!IsUkraineSupportMessageDisabled) { console.Output.WriteLine( "┌────────────────────────────────────────────────────────────────────┐" ); console.Output.WriteLine( "│ Thank you for supporting Ukraine <3 │" ); console.Output.WriteLine( "│ │" ); console.Output.WriteLine( "│ As Russia wages a genocidal war against my country, │" ); console.Output.WriteLine( "│ I'm grateful to everyone who continues to │" ); console.Output.WriteLine( "│ stand with Ukraine in our fight for freedom. │" ); console.Output.WriteLine( "│ │" ); console.Output.WriteLine( "│ Learn more: https://tyrrrz.me/ukraine │" ); console.Output.WriteLine( "└────────────────────────────────────────────────────────────────────┘" ); console.Output.WriteLine(""); } await base.ExecuteAsync(console); } }
```

# Commands/Converters/ThreadInclusionModeBindingConverter.cs

```cs
using System; using CliFx.Extensibility; using DiscordChatExporter.Cli.Commands.Shared; namespace DiscordChatExporter.Cli.Commands.Converters; internal class ThreadInclusionModeBindingConverter : BindingConverter<ThreadInclusionMode> { public override ThreadInclusionMode Convert(string? rawValue) { // Empty or unset value is treated as 'active' to match the previous behavior if (string.IsNullOrWhiteSpace(rawValue)) return ThreadInclusionMode.Active; // Boolean 'true' is treated as 'active', boolean 'false' is treated as 'none' if (bool.TryParse(rawValue, out var boolValue)) return boolValue ? ThreadInclusionMode.Active : ThreadInclusionMode.None; // Otherwise, fall back to regular enum parsing return Enum.Parse<ThreadInclusionMode>(rawValue, true); } }
```

# Commands/Converters/TruthyBooleanBindingConverter.cs

```cs
using System.Globalization; using CliFx.Extensibility; namespace DiscordChatExporter.Cli.Commands.Converters; internal class TruthyBooleanBindingConverter : BindingConverter<bool> { public override bool Convert(string? rawValue) { // Empty or unset value is treated as 'true', to match the regular boolean behavior if (string.IsNullOrWhiteSpace(rawValue)) return true; // Number '1' is treated as 'true', other numbers are treated as 'false' if (int.TryParse(rawValue, CultureInfo.InvariantCulture, out var intValue)) return intValue == 1; // Otherwise, fall back to regular boolean parsing return bool.Parse(rawValue); } }
```

# Commands/ExportAllCommand.cs

```cs
using System; using System.Collections.Generic; using System.Linq; using System.Threading.Tasks; using CliFx.Attributes; using CliFx.Infrastructure; using DiscordChatExporter.Cli.Commands.Base; using DiscordChatExporter.Cli.Commands.Converters; using DiscordChatExporter.Cli.Commands.Shared; using DiscordChatExporter.Cli.Utils.Extensions; using DiscordChatExporter.Core.Discord.Data; using DiscordChatExporter.Core.Discord.Dump; using DiscordChatExporter.Core.Exceptions; using Spectre.Console; namespace DiscordChatExporter.Cli.Commands; [Command("exportall", Description = "Exports all accessible channels.")] public class ExportAllCommand : ExportCommandBase { [CommandOption("include-dm", Description = "Include direct message channels.")] public bool IncludeDirectChannels { get; init; } = true; [CommandOption("include-guilds", Description = "Include server channels.")] public bool IncludeGuildChannels { get; init; } = true; [CommandOption("include-vc", Description = "Include voice channels.")] public bool IncludeVoiceChannels { get; init; } = true; [CommandOption( "include-threads", Description = "Which types of threads should be included.", Converter = typeof(ThreadInclusionModeBindingConverter) )] public ThreadInclusionMode ThreadInclusionMode { get; init; } = ThreadInclusionMode.None; [CommandOption( "data-package", Description = "Path to the personal data package (ZIP file) requested from Discord. " + "If provided, only channels referenced in the dump will be exported." )] public string? DataPackageFilePath { get; init; } public override async ValueTask ExecuteAsync(IConsole console) { await base.ExecuteAsync(console); var cancellationToken = console.RegisterCancellationHandler(); var channels = new List<Channel>(); // Pull from the API if (string.IsNullOrWhiteSpace(DataPackageFilePath)) { await foreach (var guild in Discord.GetUserGuildsAsync(cancellationToken)) { // Regular channels await console.Output.WriteLineAsync( $"Fetching channels for server '{guild.Name}'..." ); var fetchedChannelsCount = 0; await console .CreateStatusTicker() .StartAsync( "...", async ctx => { await foreach ( var channel in Discord.GetGuildChannelsAsync( guild.Id, cancellationToken ) ) { if (channel.IsCategory) continue; if (!IncludeVoiceChannels && channel.IsVoice) continue; channels.Add(channel); ctx.Status( Markup.Escape($"Fetched '{channel.GetHierarchicalName()}'.") ); fetchedChannelsCount++; } } ); await console.Output.WriteLineAsync($"Fetched {fetchedChannelsCount} channel(s)."); // Threads if (ThreadInclusionMode != ThreadInclusionMode.None) { await console.Output.WriteLineAsync( $"Fetching threads for server '{guild.Name}'..." ); var fetchedThreadsCount = 0; await console .CreateStatusTicker() .StartAsync( "...", async ctx => { await foreach ( var thread in Discord.GetGuildThreadsAsync( guild.Id, ThreadInclusionMode == ThreadInclusionMode.All, Before, After, cancellationToken ) ) { channels.Add(thread); ctx.Status( Markup.Escape($"Fetched '{thread.GetHierarchicalName()}'.") ); fetchedThreadsCount++; } } ); await console.Output.WriteLineAsync( $"Fetched {fetchedThreadsCount} thread(s)." ); } } } // Pull from the data package else { await console.Output.WriteLineAsync("Extracting channels..."); var dump = await DataDump.LoadAsync(DataPackageFilePath, cancellationToken); var inaccessibleChannels = new List<DataDumpChannel>(); await console .CreateStatusTicker() .StartAsync( "...", async ctx => { foreach (var dumpChannel in dump.Channels) { ctx.Status( Markup.Escape( $"Fetching '{dumpChannel.Name}' ({dumpChannel.Id})..." ) ); try { var channel = await Discord.GetChannelAsync( dumpChannel.Id, cancellationToken ); channels.Add(channel); } catch (DiscordChatExporterException) { inaccessibleChannels.Add(dumpChannel); } } } ); await console.Output.WriteLineAsync($"Fetched {channels} channel(s)."); // Print inaccessible channels if (inaccessibleChannels.Any()) { await console.Output.WriteLineAsync(); using (console.WithForegroundColor(ConsoleColor.Red)) { await console.Error.WriteLineAsync( "Failed to access the following channel(s):" ); } foreach (var dumpChannel in inaccessibleChannels) await console.Error.WriteLineAsync($"{dumpChannel.Name} ({dumpChannel.Id})"); await console.Error.WriteLineAsync(); } } // Filter out unwanted channels if (!IncludeDirectChannels) channels.RemoveAll(c => c.IsDirect); if (!IncludeGuildChannels) channels.RemoveAll(c => c.IsGuild); if (!IncludeVoiceChannels) channels.RemoveAll(c => c.IsVoice); if (ThreadInclusionMode == ThreadInclusionMode.None) channels.RemoveAll(c => c.IsThread); if (ThreadInclusionMode != ThreadInclusionMode.All) channels.RemoveAll(c => c is { IsThread: true, IsArchived: true }); await ExportAsync(console, channels); } }
```

# Commands/ExportChannelsCommand.cs

```cs
using System.Collections.Generic; using System.Threading.Tasks; using CliFx.Attributes; using CliFx.Infrastructure; using DiscordChatExporter.Cli.Commands.Base; using DiscordChatExporter.Core.Discord; namespace DiscordChatExporter.Cli.Commands; [Command("export", Description = "Exports one or multiple channels.")] public class ExportChannelsCommand : ExportCommandBase { // TODO: change this to plural (breaking change) [CommandOption( "channel", 'c', Description = "Channel ID(s). " + "If provided with category ID(s), all channels inside those categories will be exported." )] public required IReadOnlyList<Snowflake> ChannelIds { get; init; } public override async ValueTask ExecuteAsync(IConsole console) { await base.ExecuteAsync(console); await ExportAsync(console, ChannelIds); } }
```

# Commands/ExportDirectMessagesCommand.cs

```cs
using System.Threading.Tasks; using CliFx.Attributes; using CliFx.Infrastructure; using DiscordChatExporter.Cli.Commands.Base; using DiscordChatExporter.Core.Discord.Data; using DiscordChatExporter.Core.Utils.Extensions; namespace DiscordChatExporter.Cli.Commands; [Command("exportdm", Description = "Exports all direct message channels.")] public class ExportDirectMessagesCommand : ExportCommandBase { public override async ValueTask ExecuteAsync(IConsole console) { await base.ExecuteAsync(console); var cancellationToken = console.RegisterCancellationHandler(); await console.Output.WriteLineAsync("Fetching channels..."); var channels = await Discord.GetGuildChannelsAsync( Guild.DirectMessages.Id, cancellationToken ); await ExportAsync(console, channels); } }
```

# Commands/ExportGuildCommand.cs

```cs
using System.Collections.Generic; using System.Threading.Tasks; using CliFx.Attributes; using CliFx.Infrastructure; using DiscordChatExporter.Cli.Commands.Base; using DiscordChatExporter.Cli.Commands.Converters; using DiscordChatExporter.Cli.Commands.Shared; using DiscordChatExporter.Cli.Utils.Extensions; using DiscordChatExporter.Core.Discord; using DiscordChatExporter.Core.Discord.Data; using Spectre.Console; namespace DiscordChatExporter.Cli.Commands; [Command("exportguild", Description = "Exports all channels within the specified server.")] public class ExportGuildCommand : ExportCommandBase { [CommandOption("guild", 'g', Description = "Server ID.")] public required Snowflake GuildId { get; init; } [CommandOption("include-vc", Description = "Include voice channels.")] public bool IncludeVoiceChannels { get; init; } = true; [CommandOption( "include-threads", Description = "Which types of threads should be included.", Converter = typeof(ThreadInclusionModeBindingConverter) )] public ThreadInclusionMode ThreadInclusionMode { get; init; } = ThreadInclusionMode.None; public override async ValueTask ExecuteAsync(IConsole console) { await base.ExecuteAsync(console); var cancellationToken = console.RegisterCancellationHandler(); var channels = new List<Channel>(); // Regular channels await console.Output.WriteLineAsync("Fetching channels..."); var fetchedChannelsCount = 0; await console .CreateStatusTicker() .StartAsync( "...", async ctx => { await foreach ( var channel in Discord.GetGuildChannelsAsync(GuildId, cancellationToken) ) { if (channel.IsCategory) continue; if (!IncludeVoiceChannels && channel.IsVoice) continue; channels.Add(channel); ctx.Status(Markup.Escape($"Fetched '{channel.GetHierarchicalName()}'.")); fetchedChannelsCount++; } } ); await console.Output.WriteLineAsync($"Fetched {fetchedChannelsCount} channel(s)."); // Threads if (ThreadInclusionMode != ThreadInclusionMode.None) { await console.Output.WriteLineAsync("Fetching threads..."); var fetchedThreadsCount = 0; await console .CreateStatusTicker() .StartAsync( "...", async ctx => { await foreach ( var thread in Discord.GetGuildThreadsAsync( GuildId, ThreadInclusionMode == ThreadInclusionMode.All, Before, After, cancellationToken ) ) { channels.Add(thread); ctx.Status(Markup.Escape($"Fetched '{thread.GetHierarchicalName()}'.")); fetchedThreadsCount++; } } ); await console.Output.WriteLineAsync($"Fetched {fetchedThreadsCount} thread(s)."); } await ExportAsync(console, channels); } }
```

# Commands/GetChannelsCommand.cs

```cs
using System; using System.Linq; using System.Threading.Tasks; using CliFx.Attributes; using CliFx.Infrastructure; using DiscordChatExporter.Cli.Commands.Base; using DiscordChatExporter.Cli.Commands.Converters; using DiscordChatExporter.Cli.Commands.Shared; using DiscordChatExporter.Core.Discord; using DiscordChatExporter.Core.Utils.Extensions; namespace DiscordChatExporter.Cli.Commands; [Command("channels", Description = "Get the list of channels in a server.")] public class GetChannelsCommand : DiscordCommandBase { [CommandOption("guild", 'g', Description = "Server ID.")] public required Snowflake GuildId { get; init; } [CommandOption("include-vc", Description = "Include voice channels.")] public bool IncludeVoiceChannels { get; init; } = true; [CommandOption( "include-threads", Description = "Which types of threads should be included.", Converter = typeof(ThreadInclusionModeBindingConverter) )] public ThreadInclusionMode ThreadInclusionMode { get; init; } = ThreadInclusionMode.None; public override async ValueTask ExecuteAsync(IConsole console) { await base.ExecuteAsync(console); var cancellationToken = console.RegisterCancellationHandler(); var channels = (await Discord.GetGuildChannelsAsync(GuildId, cancellationToken)) .Where(c => !c.IsCategory) .Where(c => IncludeVoiceChannels || !c.IsVoice) .OrderBy(c => c.Parent?.Position) .ThenBy(c => c.Name) .ToArray(); var channelIdMaxLength = channels .Select(c => c.Id.ToString().Length) .OrderDescending() .FirstOrDefault(); var threads = ThreadInclusionMode != ThreadInclusionMode.None ? ( await Discord.GetGuildThreadsAsync( GuildId, ThreadInclusionMode == ThreadInclusionMode.All, null, null, cancellationToken ) ) .OrderBy(c => c.Name) .ToArray() : []; foreach (var channel in channels) { // Channel ID await console.Output.WriteAsync( channel.Id.ToString().PadRight(channelIdMaxLength, ' ') ); // Separator using (console.WithForegroundColor(ConsoleColor.DarkGray)) await console.Output.WriteAsync(" | "); // Channel name using (console.WithForegroundColor(ConsoleColor.White)) await console.Output.WriteLineAsync(channel.GetHierarchicalName()); var channelThreads = threads.Where(t => t.Parent?.Id == channel.Id).ToArray(); var channelThreadIdMaxLength = channelThreads .Select(t => t.Id.ToString().Length) .OrderDescending() .FirstOrDefault(); foreach (var channelThread in channelThreads) { // Indent await console.Output.WriteAsync(" * "); // Thread ID await console.Output.WriteAsync( channelThread.Id.ToString().PadRight(channelThreadIdMaxLength, ' ') ); // Separator using (console.WithForegroundColor(ConsoleColor.DarkGray)) await console.Output.WriteAsync(" | "); // Thread name using (console.WithForegroundColor(ConsoleColor.White)) await console.Output.WriteAsync($"Thread / {channelThread.Name}"); // Separator using (console.WithForegroundColor(ConsoleColor.DarkGray)) await console.Output.WriteAsync(" | "); // Thread status using (console.WithForegroundColor(ConsoleColor.White)) await console.Output.WriteLineAsync( channelThread.IsArchived ? "Archived" : "Active" ); } } } }
```

# Commands/GetDirectChannelsCommand.cs

```cs
using System; using System.Linq; using System.Threading.Tasks; using CliFx.Attributes; using CliFx.Infrastructure; using DiscordChatExporter.Cli.Commands.Base; using DiscordChatExporter.Core.Discord.Data; using DiscordChatExporter.Core.Utils.Extensions; namespace DiscordChatExporter.Cli.Commands; [Command("dm", Description = "Gets the list of all direct message channels.")] public class GetDirectChannelsCommand : DiscordCommandBase { public override async ValueTask ExecuteAsync(IConsole console) { await base.ExecuteAsync(console); var cancellationToken = console.RegisterCancellationHandler(); var channels = ( await Discord.GetGuildChannelsAsync(Guild.DirectMessages.Id, cancellationToken) ) .OrderByDescending(c => c.LastMessageId) .ThenBy(c => c.Name) .ToArray(); var channelIdMaxLength = channels .Select(c => c.Id.ToString().Length) .OrderDescending() .FirstOrDefault(); foreach (var channel in channels) { // Channel ID await console.Output.WriteAsync( channel.Id.ToString().PadRight(channelIdMaxLength, ' ') ); // Separator using (console.WithForegroundColor(ConsoleColor.DarkGray)) await console.Output.WriteAsync(" | "); // Channel name using (console.WithForegroundColor(ConsoleColor.White)) await console.Output.WriteLineAsync(channel.GetHierarchicalName()); } } }
```

# Commands/GetGuildsCommand.cs

```cs
using System; using System.Linq; using System.Threading.Tasks; using CliFx.Attributes; using CliFx.Infrastructure; using DiscordChatExporter.Cli.Commands.Base; using DiscordChatExporter.Core.Discord.Data; using DiscordChatExporter.Core.Utils.Extensions; namespace DiscordChatExporter.Cli.Commands; [Command("guilds", Description = "Gets the list of accessible servers.")] public class GetGuildsCommand : DiscordCommandBase { public override async ValueTask ExecuteAsync(IConsole console) { await base.ExecuteAsync(console); var cancellationToken = console.RegisterCancellationHandler(); var guilds = (await Discord.GetUserGuildsAsync(cancellationToken)) // Show direct messages first .OrderByDescending(g => g.Id == Guild.DirectMessages.Id) .ThenBy(g => g.Name) .ToArray(); var guildIdMaxLength = guilds .Select(g => g.Id.ToString().Length) .OrderDescending() .FirstOrDefault(); foreach (var guild in guilds) { // Guild ID await console.Output.WriteAsync(guild.Id.ToString().PadRight(guildIdMaxLength, ' ')); // Separator using (console.WithForegroundColor(ConsoleColor.DarkGray)) await console.Output.WriteAsync(" | "); // Guild name using (console.WithForegroundColor(ConsoleColor.White)) await console.Output.WriteLineAsync(guild.Name); } } }
```

# Commands/GuideCommand.cs

```cs
using System; using System.Threading.Tasks; using CliFx; using CliFx.Attributes; using CliFx.Infrastructure; namespace DiscordChatExporter.Cli.Commands; [Command("guide", Description = "Explains how to obtain the token, server or channel ID.")] public class GuideCommand : ICommand { public ValueTask ExecuteAsync(IConsole console) { // User token using (console.WithForegroundColor(ConsoleColor.White)) console.Output.WriteLine("To get the token for your personal account:"); console.Output.WriteLine( " * Automating user accounts is technically against TOS — USE AT YOUR OWN RISK!" ); console.Output.WriteLine(" 1. Open Discord in your web browser and login"); console.Output.WriteLine(" 2. Open any server or direct message channel"); console.Output.WriteLine(" 3. Press Ctrl+Shift+I to show developer tools"); console.Output.WriteLine(" 4. Navigate to the Network tab"); console.Output.WriteLine(" 5. Press Ctrl+R to reload"); console.Output.WriteLine(" 6. Switch between random channels to trigger network requests"); console.Output.WriteLine(" 7. Search for a request that starts with \"messages\""); console.Output.WriteLine(" 8. Select the Headers tab on the right"); console.Output.WriteLine(" 9. Scroll down to the Request Headers section"); console.Output.WriteLine(" 10. Copy the value of the \"authorization\" header"); console.Output.WriteLine(); // Bot token using (console.WithForegroundColor(ConsoleColor.White)) console.Output.WriteLine("To get the token for your bot:"); console.Output.WriteLine(" 1. Go to Discord developer portal"); console.Output.WriteLine(" 2. Open your application's settings"); console.Output.WriteLine(" 3. Navigate to the Bot section on the left"); console.Output.WriteLine(" 4. Under Token click Copy"); console.Output.WriteLine( " * Your bot needs to have the Message Content Intent enabled to read messages" ); console.Output.WriteLine(); // Guild or channel ID using (console.WithForegroundColor(ConsoleColor.White)) console.Output.WriteLine("To get the ID of a server or a channel:"); console.Output.WriteLine(" 1. Open Discord"); console.Output.WriteLine(" 2. Open Settings"); console.Output.WriteLine(" 3. Go to Advanced section"); console.Output.WriteLine(" 4. Enable Developer Mode"); console.Output.WriteLine( " 5. Right-click on the desired server or channel and click Copy Server ID or Copy Channel ID" ); console.Output.WriteLine(); // Docs link using (console.WithForegroundColor(ConsoleColor.White)) { console.Output.WriteLine( "If you have questions or issues, please refer to the documentation:" ); } using (console.WithForegroundColor(ConsoleColor.DarkCyan)) { console.Output.WriteLine( "https://github.com/Tyrrrz/DiscordChatExporter/blob/master/.docs" ); } return default; } }
```

# Commands/Shared/ThreadInclusionMode.cs

```cs
namespace DiscordChatExporter.Cli.Commands.Shared; public enum ThreadInclusionMode { None, Active, All, }
```

# DiscordChatExporter.Cli.csproj

```csproj
<Project Sdk="Microsoft.NET.Sdk"> <PropertyGroup> <OutputType>Exe</OutputType> <ApplicationIcon>..\favicon.ico</ApplicationIcon> <PublishTrimmed>true</PublishTrimmed> <CopyOutputSymbolsToPublishDirectory>false</CopyOutputSymbolsToPublishDirectory> </PropertyGroup> <ItemGroup> <PackageReference Include="CliFx" Version="2.3.5" /> <PackageReference Include="CSharpier.MsBuild" Version="0.29.2" PrivateAssets="all" /> <PackageReference Include="Deorcify" Version="1.0.2" PrivateAssets="all" /> <PackageReference Include="Gress" Version="2.1.1" /> <PackageReference Include="Spectre.Console" Version="0.49.1" /> </ItemGroup> <ItemGroup> <ProjectReference Include="..\DiscordChatExporter.Core\DiscordChatExporter.Core.csproj" /> </ItemGroup> </Project>
```

# Program.cs

```cs
using System.Diagnostics.CodeAnalysis; using System.Threading.Tasks; using CliFx; using DiscordChatExporter.Cli.Commands; using DiscordChatExporter.Cli.Commands.Converters; using DiscordChatExporter.Core.Exporting.Filtering; using DiscordChatExporter.Core.Exporting.Partitioning; namespace DiscordChatExporter.Cli; public static class Program { // Explicit references because CliFx relies on reflection and we're publishing with trimming enabled [DynamicDependency(DynamicallyAccessedMemberTypes.All, typeof(ExportAllCommand))] [DynamicDependency(DynamicallyAccessedMemberTypes.All, typeof(ExportChannelsCommand))] [DynamicDependency(DynamicallyAccessedMemberTypes.All, typeof(ExportDirectMessagesCommand))] [DynamicDependency(DynamicallyAccessedMemberTypes.All, typeof(ExportGuildCommand))] [DynamicDependency(DynamicallyAccessedMemberTypes.All, typeof(GetChannelsCommand))] [DynamicDependency(DynamicallyAccessedMemberTypes.All, typeof(GetDirectChannelsCommand))] [DynamicDependency(DynamicallyAccessedMemberTypes.All, typeof(GetGuildsCommand))] [DynamicDependency(DynamicallyAccessedMemberTypes.All, typeof(GuideCommand))] [DynamicDependency( DynamicallyAccessedMemberTypes.All, typeof(ThreadInclusionModeBindingConverter) )] [DynamicDependency(DynamicallyAccessedMemberTypes.All, typeof(TruthyBooleanBindingConverter))] [DynamicDependency(DynamicallyAccessedMemberTypes.All, typeof(PartitionLimit))] [DynamicDependency(DynamicallyAccessedMemberTypes.All, typeof(MessageFilter))] public static async Task<int> Main(string[] args) => await new CliApplicationBuilder() .AddCommand<ExportAllCommand>() .AddCommand<ExportChannelsCommand>() .AddCommand<ExportDirectMessagesCommand>() .AddCommand<ExportGuildCommand>() .AddCommand<GetChannelsCommand>() .AddCommand<GetDirectChannelsCommand>() .AddCommand<GetGuildsCommand>() .AddCommand<GuideCommand>() .Build() .RunAsync(args); }
```

# Utils/Extensions/ConsoleExtensions.cs

```cs
using System; using System.Threading.Tasks; using CliFx.Infrastructure; using Spectre.Console; namespace DiscordChatExporter.Cli.Utils.Extensions; internal static class ConsoleExtensions { public static IAnsiConsole CreateAnsiConsole(this IConsole console) => AnsiConsole.Create( new AnsiConsoleSettings { Ansi = AnsiSupport.Detect, ColorSystem = ColorSystemSupport.Detect, Out = new AnsiConsoleOutput(console.Output), } ); public static Status CreateStatusTicker(this IConsole console) => console.CreateAnsiConsole().Status().AutoRefresh(true); public static Progress CreateProgressTicker(this IConsole console) => console .CreateAnsiConsole() .Progress() .AutoClear(false) .AutoRefresh(true) .HideCompleted(false) .Columns( new TaskDescriptionColumn { Alignment = Justify.Left }, new ProgressBarColumn(), new PercentageColumn() ); public static async ValueTask StartTaskAsync( this ProgressContext context, string description, Func<ProgressTask, ValueTask> performOperationAsync ) { // Description cannot be empty // https://github.com/Tyrrrz/DiscordChatExporter/issues/1133 var actualDescription = !string.IsNullOrWhiteSpace(description) ? description : "..."; var progressTask = context.AddTask( actualDescription, new ProgressTaskSettings { MaxValue = 1 } ); try { await performOperationAsync(progressTask); } finally { progressTask.Value = progressTask.MaxValue; progressTask.StopTask(); } } }
```

